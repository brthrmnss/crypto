var assert = require('assert');
var util = require('util');
var url = require('url');
var http = require('http');
var https = require('https');
var is = require('type-is');
var getRawBody = require('raw-body');
var sh = require('shelpers').shelpers

var cookie = require('cookie');
require('buffer');

var request = require('request');
request = request.defaults({jar: true,
  //followAllRedirect:false,
  //followRedirect: false,
  rejectUnauthorized:false});


var proxyPreamble =  '/proxy?url='

module.exports = function proxy(host, options) {

  assert(host, 'Host should not be empty');

  options = options || {};

  var port = 80;

  var ishttps = /^https/.test(host);

  if (typeof host == 'string') {
    var mc = host.match(/^(https?:\/\/)/);
    if (mc) {
      host = host.substring(mc[1].length);
    }

    var h = host.split(':');
    if (h[1] === '443') {
      ishttps = true;
    }

    host = h[0];
    port = h[1] || (ishttps ? 443 : 80);
    port = String.prototype.replace.call(port, '/', '');
  }

  port = options.port || port;


  /**
   * intercept(targetResponse, data, res, req, function(err, json));
   */
  var intercept = options.intercept;
  var decorateRequest = options.decorateRequest;
  var forwardPath = options.forwardPath;
  var filter = options.filter;
  var limit = options.limit || '1mb';
  var preserveHostHdr = options.preserveHostHdr;

  return function handleProxy(req, res, next) {
    if (filter && !filter(req, res)) return next();

    var headers = options.headers || {};
    var path;

    path = forwardPath ? forwardPath(req, res) : url.parse(req.url).path;

    var skipHdrs = [ 'connection', 'content-length' ];
    if (!preserveHostHdr) {
      skipHdrs.push('host');
    }
    var hds = extend(headers, req.headers, skipHdrs);
    hds.connection = 'close';

    // var hasRequestBody = 'content-type' in req.headers || 'transfer-encoding' in req.headers;
    getRawBody(req, {
      length: req.headers['content-length'],
      limit: limit
    }, function(err, bodyContent) {
      if (err) return next(err);

      var reqOpt = {
        hostname: (typeof host == 'function') ? host(req) : host.toString(),
        port: port,
        headers: hds,
        method: req.method,
        path: (typeof options.fxGetPath == 'function') ? options.fxGetPath(req) : path.toString(),
        bodyContent: bodyContent,
        params: req.params
      };


      if (decorateRequest)
        reqOpt = decorateRequest(reqOpt) || reqOpt;

      bodyContent = reqOpt.bodyContent;
      delete reqOpt.bodyContent;
      delete reqOpt.params;

      if (typeof bodyContent == 'string')
        reqOpt.headers['content-length'] = Buffer.byteLength(bodyContent);
      else if (Buffer.isBuffer(bodyContent)) // Buffer
        reqOpt.headers['content-length'] = bodyContent.length;

      var chunks = [];
      console.log('boooy', reqOpt.hostname, reqOpt.path)


      var url = reqOpt.hostname+ reqOpt.path

      if ( sh.includes(url, '://') == false ) {
        if (https) {
          url = 'https://' + url
        } else {
          url = 'http://' + url
        }
      }

      if ( sh.includes(reqOpt.hostname,reqOpt.path)) {
        //why: images fucked up
        //boooy https://ssl.gstatic.com/accounts/ui/avatar_2x.png /accounts/ui/avatar_2x.png
        //    xyxysdf https://ssl.gstatic.com/accounts/ui/avatar_2x.png/accounts/ui/avatar_2x.png

        url = reqOpt.hostname;
      }

      var reqoptions = {}
      console.log('url to request', url, req.method)

      if ( sh.endsWith(url,'.png') ) {
        reqoptions.encoding = null
      }

      reqoptions.url  = url;
      reqoptions.method = req.method;
      var postData = bodyContent

      var types = {};
      types.POST = 'POST'
      types.GET = 'GET'
      types.PUT = 'PUT'

      var debug = {};
      debug.cookies = false;

      var contentType = req.headers['content-type']

      var isForm = sh.includes(contentType, 'x-www-form-urlencoded', true );

      if ( contentType == 'application/json' || isForm ) {
        var dataJSON = bodyContent.toString();
        var dataJSON2 = bodyContent.toString('utf8');
        var postJSON = true;
        var doRegPost = false;
        if (reqoptions.method == types.POST || reqoptions.method  == types.PUT) {
          if (doRegPost == 'fileupload') {
            //reqoptions.json = true
            //reqoptions.body = postData;
            reqoptions.encoding = null;
          }
          else if ( isForm ) {
            reqoptions.form = postData;
            console.error(postData, dataJSON, dataJSON2)
            var qs = require('qs')
            var val = qs.parse(dataJSON)
            console.log(val)
            reqoptions.form = val;
            //  console.error( dataJSON )
            console.error( 'form:', contentType )
            // console.error('ssdf',req )
          } else {
            //reqoptions.json = true
            //reqoptions.body = "gg"

            reqoptions.body = postData;

            if (postJSON != false) {
              reqoptions.json = true;
              reqoptions.body = JSON.parse(dataJSON);
              delete reqoptions.encoding;


              //reqoptions.json = true;
              /*  reqoptions.body =  dataJSON;
               delete reqoptions.encoding;*/
            }
          }
        } else {
          reqoptions.qs = postData
        }
      }

      //console.error('what is request1', req, contentType, bodyContent)
      console.error('what is request2', reqoptions, contentType, bodyContent)

      function copyHeadersOver() {

        var upgrade = hds['upgrade-insecure-requests']
        if ( upgrade ) {
          hds['upgrade-insecure-requests'] = upgrade;
        }
        console.error("\t", "\t",'asdf... headers', hds)
      }
      copyHeadersOver();

      request(reqoptions, function (error, response, body) {
        if (response != null && body == null) {
          body = response.body;
        }

        if ( error ) {
          console.error(error);
        }

        if ( sh.isString( body )  ) {
          var responseEnconding = response.headers['content-type'];
          console.log('is404?', body.indexOf('404') == -1, 7, url, responseEnconding )

          if ( responseEnconding !== null ) {

            var url2 = url
            if (sh.includes(url2, '?')) {
              console.log('hit this...')
              url2 = url2.split('?')[1]
            }
            var filenameSave = sh.stripSpecialChars(url2);
            filenameSave = 'testFiles/' + filenameSave;
            var tidy = require('htmltidy').tidy;

            if (sh.includes(responseEnconding, 'text/html', true)) {
              tidy(body, function (err, html) {
                if (err == null || err == '') {
                  sh.writeFile(filenameSave, html)
                  sh.writeFile(filenameSave + '.html', html)

                  //  finishDl(error, response, html)
                } else {
                  console.error('error with tidying', err, err == null, JSON.stringify(err))
                  sh.writeFile(filenameSave, body)

                  //   finishDl(error, response, body)
                }

                //console.log(html);
              });
            } else {
              sh.writeFile('testFiles/' + sh.stripBadFiles(url), body)
              // finishDl(error, response, body)
            }
/*

            finishDl(error, response, body)

          }

          function finishDl(error, response, body) {

*/

            var find = 'https://ssl.gstatic.com/accounts/ui/wlogostrip_230x17_1x.png'
            body = body.replace(find, 'sdfsdfsdfsdf')

            var find = 'https://ssl.gstatic.com/accounts/ui/avatar_2x.png'
            body = body.replace(find, '/proxy?url=' + find)

            var find = 'https://accounts.google.com/AccountLoginInfo'
            body = body.replace(find, '/proxy?url=' + find)

            var find = 'https://mail.google.com/mail/'
            //body = body.replace(find, '/proxy?url=' + find)

            var find = 'https://accounts.google.com/signin/challenge/sl/password'
            body = body.replace(find, '/proxy?url=' + find)

            var find = '"/signin/challenge/sl/password'
            body = body.replace(find, '"'+'/proxy?url=' +
                'https://accounts.google.com' + find)

            var find = 'if (!a)a'
            body = body.replace(find, 'debugger; '+find);


            var find = 'z._ValidateBrowser=function(){'
            body = sh.replace(body, find, find+'location.href2=\'\'; console.info(\'inside\'); return; return; ')

            find = 'a.href='
            body = sh.replace(body, find,  'a.h=')
            if ( sh.includes(body, find)) {
              console.log('*****************************************')
            }
            find = '.location='
            body = sh.replace(body, find,  '.locationZZZ=')
            find = '.location ='
            body = sh.replace(body, find,  '.locationZZZ =')
            find = '.location'
            body = sh.replace(body, find,  '.locationYYY')
            find = '.href'
            body = sh.replace(body, find,  '.href2')
            /*
             find = 'iframe'
             body = sh.replace(body, find,  'iframex')
             */

            // find = '<iframe id=js_frame'
            //body = sh.replace(body, find,  '<iframex id=js_frame')
            /*

             find = '){'
             body = sh.replace(body, find,  '){debugger;')
             */
            /*
            find = ';'
            body = sh.replace(body, find,  'debugger;')
            find = '{'
            body = sh.replace(body, find,  '{debugger;')
            */
          }
        }
        //if () {
        if ( response == null ) {
          console.error('response is null ... what happaned', error)
          res.send('')
          return;
        }

        ///}
        console.log('response',  response.statusCode)
        if ( debug.cookies ) {
          console.log('response headers', response.headers)
        }
        var contentType = response.headers['content-type'];
        //if () {


        //}
        var testWhichBreaks = true
        var count = 0;
        sh.each(response.headers, function copyHeader(k,v) {
          // res.addheader(k,v)
          count++
          if ( testWhichBreaks && count < 150) {
            //console.log('k', k)
            //res.setHeader(k, v)
            // return
          } else{
            return
          }

          if (k == 'set-cookie'){
            sh.each(v, function addCookie(i, cook) {

              var cookies = cookie.parse(cook);
              var other = {};
              var cookieName = ''
              var cookieValue = ''
              sh.each(cookies, function addCookie(kk, vv) {
                    var l = kk.toLowerCase();
                    if (l == 'path') {
                      //other.path = vv;
                      return;
                    }
                    if (l == 'secure') {
                      other.path = vv;
                      return;
                    }
                    if (l == 'httponly') {
                      other.httpOnly = vv;
                      return;
                    }
                    if (l == 'expires') {
                      //other.expires = vv;
                      return;
                    }
                    if (l == 'domain') {
                      //other.domain = vv;
                      return;
                    }
                    cookieName = kk;
                    cookieValue = vv;
                  }
              )

              if ( cook.indexOf(';Secure')!= -1 ) {
                //other.secure = true;
              }
              res.cookie(cookieName, cookieValue, other)
              if ( debug.cookies ) {
                console.log('cookies', i, cookies, cook)
                console.error('cookies', '  ', '\t', cookieName, cookieValue, other)
              }
            });
          }

          //res.cookie('llll', 'jdjjjj', {secure:true})
          //res.cookie('llldl', 'jdjjjj', {secure:false})
          //https://github.com/nodejs/node/issues/5754
          //https://github.com/request/request/issues/2091
          var skipTypes = ['set-cookie'];//, 'content-type']
          if ( sh.isAnyInAny(k, skipTypes) == false ){
            return
          }
          // console.log('k', k)
          res.setHeader(k,v)
        })

        if ( debug.cookies ) {
          if (req.cookies) {
            sh.each(req.cookies, function addCookie(i, cook) {
              console.log(i, cook)
            });
          }
        }

        res.statusCode = response.statusCode;

        if ( response.statusCode == 302 ) {
          res.redirect(  proxyPreamble + response.headers['location']);
          return;
        }

        if ( sh.includes(contentType,'png') ) {
          res.send(new Buffer(body, 'binary'))
          // sh.writeFile('test.png', body, false, true)
          //  sh.writeFile('test2.png', body, false, false)
          //   res.type('png')
          //    res.end(body, 'binary')
          console.error('binary')
          return;
        }

        res.send(body)
      })



      return; //

      var realRequest = (ishttps ? https : http).request(reqOpt, function(rsp) {
        var rspData = null;
        rsp.on('data', function(chunk) {
          chunks.push(chunk);
        });

        rsp.on('end', function() {
          var totalLength = chunks.reduce(function(len, buf) {
            return len + buf.length;
          }, 0);

          var rspData = Buffer.concat(chunks, totalLength);

          if (intercept) {
            intercept(rsp, rspData, req, res, function(err, rspd, sent) {
              if (err) {
                return next(err);
              }

              var encode = 'utf8';
              if (rsp.headers && rsp.headers['content-type']) {
                var contentType = rsp.headers['content-type'];
                if (/charset=/.test(contentType)) {
                  var attrs = contentType.split(';').map(function(str) { return str.trim(); });
                  for(var i = 0, len = attrs.length; i < len; i++) {
                    var attr = attrs[i];
                    if (/charset=/.test(attr)) {
                      // encode = attr.split('=')[1];
                      break;
                    }
                  }
                }
              }

              if (typeof rspd == 'string')
                rspd = new Buffer(rspd, encode);

              if (!Buffer.isBuffer(rspd)) {
                next(new Error("intercept should return string or buffer as data"));
              }

              if (!res.headersSent)
                res.set('content-length', rspd.length);
              else if (rspd.length != rspData.length) {
                next(new Error("'Content-Length' is already sent, the length of response data can not be changed"));
              }

              if (!sent) {
                res.send(rspd);
              }
            });
          } else {
            res.send(rspData);
          }
        });

        rsp.on('error', function(e) {
          next(e);
        });


        if (!res.headersSent) { // if header is not set yet
          res.status(rsp.statusCode);
          for (var p in rsp.headers) {
            res.set(p, rsp.headers[p]);
          }
        }

      });

      realRequest.on('error', function(e) {
        next(e);
      });

      if (bodyContent.length) {
        realRequest.write(bodyContent);
      }

      realRequest.end();
    });
  };
};


function extend(obj, source, skips) {
  if (!source) return obj;

  for (var prop in source) {
    if (!skips || skips.indexOf(prop) == -1)
      obj[prop] = source[prop];
  }

  return obj;
}
