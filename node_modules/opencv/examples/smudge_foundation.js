var cv = require('../lib/opencv');

var fileInput = "./files/mona.png";
var fileOutput = './tmp/face-detection.png';

var fileInput = "./files/2015-06-17_212048.png";
var fileOutput = './tmp/output-fx.png'
fileInput = './files/2015-06-17_212018.png';

function kidman() {
  fileInput = "./files/2015-06-17_212048.png";
}
kidman();

function kidman2() {
    fileInput = "./files/2015-06-17_212048-out.png";
}
kidman2();

var helper = {}
helper.crop = function (box) {
  //var img_gray = helper.im.copy();
  var img_crop = helper.im.crop(box.x,box.y,box.width,box.height);
  return img_crop;
};
helper.cloneBlank = function cloneBlank(orig) {
  var result = new cv.Matrix(orig.width(), orig.height());
  return result;
};


helper.detectFace = function detectFace(fx) {
  helper.im.detectObject("../data/haarcascade_frontalface_alt.xml", {}, function (err, faces) {
    if (err) throw err;
    console.log('save faces');
    helper.faces = faces;
    for (var i = 0; i < faces.length; i++) {

      continue;
      //return;
      var face = faces[i];
      im.ellipse(face.x + face.width / 2, face.y + face.height / 2, face.width / 2, face.height / 2);
      //var faceOnly = helper.crop(face)

    }
    fx();
  });
}


helper.utils = {}
helper.utils.isBoxInBox =   function isBoxInBox(box, inBox) {
  if ( box.x < inBox.x ) {
    return false;
  }
  if ( box.y < inBox.y ) {
    return false;
  }
  if ( box.x > inBox.x + inBox.width ) {
    return false;
  }
  if ( box.y > inBox.y + inBox.height ) {
    return false;
  }

  //box ends outside
  if ( box.x + box.width > inBox.x + inBox.width ) {
    return false;
  }
  if ( box.y + box.height > inBox.y + inBox.height ) {
    return false;
  }

  return box.x < inBox.x + inBox.width &&
      box.x + box.width > inBox.x &&
      box.y < inBox.y + inBox.height &&
      box.y + box.height > inBox.y;

  return true;
}
helper.isInFace = function isInFace(box) {
  var inOneFace = false;
  for (var i = 0; i < helper.faces.length; i++) {
    var face_ = helper.faces[i];
    var face = face_
    /* face.x = box.x;
     face.y = box.y;
     face.height = box.x;
     face.height = box.height;*/
    var inBox = helper.utils.isBoxInBox(box, face);
    // im.ellipse(face.x + face.width / 2, face.y + face.height / 2, face.width / 2, face.height / 2);
    //var faceOnly = helper.crop(face)
    if ( inBox == true ) {
      return inBox;
    }

  }
  return inOneFace
}

helper.isInEye = function isInEye(box) {
  var inOneFace = false;
  for (var i = 0; i < helper.eyes.length; i++) {
    var face_ = helper.eyes[i];
    var face = face_
    var inBox = helper.utils.isBoxInBox(box, face);
    if ( inBox == true ) {
      return inBox;
    }
  }
  return inOneFace;
}


helper.drawBox = true;
helper.drawBox = false;

cv.readImage(fileInput, function(err, im) {
  if (err) throw err;
  if (im.width() < 1 || im.height() < 1) throw new Error('Image has no size');

  helper.im = im;

  helper.imOrig = im.copy();


  helper.detectFace(detectEyes);


  detectEyes();

  function detectEyes() {
    im.detectObject("../data/haarcascade_eye.xml", {},
        function (err, eyes) {
          if (err) throw err;
          console.log('eyes', eyes.length);
          helper.eyes = eyes;
          for (var i = 0; i < eyes.length; i++) {
            var face = eyes[i];
            console.log('eyes', face.x, face.width);
            //im.ellipse(face.x + face.width / 2, face.y + face.height / 2, face.width / 2, face.height / 2);
          }

          finish();
        });
  }

  function finish() {
    //im.show('./tmp/face-detection.png')
    var window = new cv.NamedWindow('Test', 0);


    var blank = helper.cloneBlank(helper.imOrig);

    var spotDection = false;
    //im.threshold(im.copy(), blank, 50,50);
    //im = blank;
    // im.threshold(  50,50);
    //im.gaussianBlur([9, 9])
    console.log('copying image');
    var im = helper.imOrig.copy();
    im.convertGrayscale();

    im.gaussianBlur([9, 9]);

    //im.gaussianBlur([3, 3]);
    //im.gaussianBlur([15, 15]);
    if (spotDection) {
      im.gaussianBlur([15, 9]); //better for spot
    }
    //im.gaussianBlur([15, 9]);
    //im.canny(5, 70, 9)
    //im.canny(0, 30, 3);
    //im.canny(2, 12, 2);
    im.canny(0, 30, 0);
    // im.houghLinesP();
    var canny = false;
    if (canny) {
      // cv.ResizeWindow(window, 500, 500);
      im.convertGrayscale()
      im.gaussianBlur([9, 9])
      im.canny(0, 30, 3)
    }


    var resizeX = false;
    if (resizeX) {
      var blank = helper.cloneBlank(im);
      // faceOnly.resize(faceOnly, blank);
      //blank.addWeighted(im, 0.7, faceOnly, 0.9);
      var m = new cv.Matrix(im.width(), im.height());
      //faceOnly.resize(im.width(),im.height());
      // im = faceOnly;
      //blank.addWeighted(im, 0.7, faceOnly, 0.9);
      //im = blank;
    }

    var contours = false
    contours = true;
    //return
    if (contours) {
      var GREEN = [0, 255, 0]; // B, G, R
      var WHITE = [255, 255, 255]; // B, G, R
      var RED = [0, 0, 255]; // B, G, R

      var minArea = 1;
      var maxArea = 50
      maxArea = 15; //smudge
      if (spotDection) {
        maxArea = 10000
        maxArea = 100; //for spot detection
      }
      contours = im.findContours();
      var minCorners = 0
      var maxCorners = 100;
      maxCorners = 0;
       // maxCorners = 20
        minCorners = 5;

      for (i = 0; i < contours.size(); i++) {

        var area = contours.area(i);
        if (area < minArea) continue;
        if (area > maxArea) continue;

        var cornerCount = contours.cornerCount(i);
        if (cornerCount < minCorners) continue;
        if (maxCorners != 0 && cornerCount > maxCorners) continue;


        var box = contours.boundingRect(i);
        if ( helper.isInFace(box) == false ) {
          continue
        }
        if ( helper.isInEye(box) == true ) {
          continue
        }


        var arcLength = contours.arcLength(i, true);
        contours.approxPolyDP(i, 0.01 * arcLength, true);
        var random = [Math.random() * 255, Math.random() * 255, Math.random() * 255];
          random = RED;
        console.log(1+i+'.', cornerCount, area );
        //console.log(cornerCount);
        if (contours.isConvex(i) == true) {
          continue;
        }
        switch (contours.cornerCount(i)) {
          case 3:
            helper.imOrig.drawContour(contours, i, GREEN);
            break;
          case 4:
            helper.imOrig.drawContour(contours, i, RED);
            break;
          default:
            helper.imOrig.drawContour(contours, i, random, 2);//(i/contours.size())*10);
        }

        if ( helper.drawBox ) {
          try {
            var box = contours.boundingRect(i);
            helper.imOrig.rectangle([box.x, box.y],
                [box.width, box.height], random, 2);
          } catch (e) {
          }
        }

        helper.imOrig.putText(i, box.x+250, box.y*1.4, null, random, 0.4 )
      }
      helper.imOrig.save(fileOutput);
    } else {
      im.save(fileOutput);
    }

    return;

    window.show(im, cv.WINDOW_AUTOSIZE);
    window.blockingWaitKey(0, 50);
    setTimeout(function () {
    }, 5 * 1000);
    //console.log('Image saved to ./tmp/face-detection.png');
  }

});
