var cv = require('../lib/opencv');

var fileInput = "./files/mona.png";
var fileOutput = './tmp/face-detection.png';

var fileInput = "./files/2015-06-17_212048.png";
var fileOutput = './tmp/output-fx.png'
//fileInput = './files/2015-06-17_212018.png';


var helper = {}
helper.crop = function (box) {
  //var img_gray = helper.im.copy();
  var img_crop = helper.im.crop(box.x,box.y,box.width,box.height);
  return img_crop;
};
helper.cloneBlank = function cloneBlank(orig) {
  var result = new cv.Matrix(orig.width(), orig.height());
  return result;
};
cv.readImage(fileInput, function(err, im){
  if (err) throw err;
  if (im.width() < 1 || im.height() < 1) throw new Error('Image has no size');

  helper.im = im;

  helper.imOrig =im.copy();

  im.detectObject("../data/haarcascade_frontalface_alt.xml", {}, function(err, faces){
    if (err) throw err;


    for (var i = 0; i < faces.length; i++){
      continue;
      //return;
      var face = faces[i];
      im.ellipse(face.x + face.width / 2, face.y + face.height / 2, face.width / 2, face.height / 2);



      //var faceOnly = helper.crop(face)

    }
    detecteyes();

    function detecteyes() {
      im.detectObject("../data/haarcascade_eye.xml", {}, function (err, faces) {
        if (err) throw err;
        console.log('eyes', faces.length);
        for (var i = 0; i < faces.length; i++) {
          var face = faces[i];
          console.log('face', face.x, face.width);
          im.ellipse(face.x + face.width / 2, face.y + face.height / 2, face.width / 2, face.height / 2);
        }
        finish();
      });
    }

    function finish() {
      //im.show('./tmp/face-detection.png')
      var window = new cv.NamedWindow('Test', 0);


      var blank = helper.cloneBlank(im);
      //im.threshold(im.copy(), blank, 50,50);
      //im = blank;
     // im.threshold(  50,50);
      //im.gaussianBlur([9, 9])
      im.convertGrayscale()
      im.gaussianBlur([9, 9])
      im.gaussianBlur([15, 9])
       im.canny(5, 70, 9)
     // im.houghLinesP();
      var canny = false;
      if (canny) {
        // cv.ResizeWindow(window, 500, 500);
        im.convertGrayscale()
        im.gaussianBlur([9, 9])
        im.canny(0, 30, 3)
      }



      var resizeX = false;
      if (resizeX) {
        var blank = helper.cloneBlank(im);
        // faceOnly.resize(faceOnly, blank);
        //blank.addWeighted(im, 0.7, faceOnly, 0.9);
        var m = new cv.Matrix(im.width(), im.height());
        //faceOnly.resize(im.width(),im.height());
        // im = faceOnly;
        //blank.addWeighted(im, 0.7, faceOnly, 0.9);
        //im = blank;
      }

      var GREEN = [0, 255, 0]; // B, G, R
      var WHITE = [255, 255, 255]; // B, G, R
      var RED   = [0, 0, 255]; // B, G, R

      var minArea = 1;
      var maxArea = 50
      maxArea = 15;
      contours = im.findContours();

      for (i = 0; i < contours.size(); i++) {

        if (contours.area(i) < minArea) continue;
        if (contours.area(i) > maxArea) continue;

        var arcLength = contours.arcLength(i, true);
        contours.approxPolyDP(i, 0.01 * arcLength, true);
        var random = [Math.random()*255,Math.random()*255,Math.random()*255];
        random = RED;
        console.log(i, contours.cornerCount(i), random);
         switch(contours.cornerCount(i)) {

          case 3:
            helper.imOrig.drawContour(contours, i, GREEN);
            break;
          case 4:
            helper.imOrig.drawContour(contours, i, RED);
            break;
          default:
            helper.imOrig.drawContour(contours, i, random);
        }
      }




      helper.imOrig.save(fileOutput);

      window.show(im, cv.WINDOW_AUTOSIZE);
      window.blockingWaitKey(0, 50);
      setTimeout(function () {
      }, 5 * 1000);
      //console.log('Image saved to ./tmp/face-detection.png');
    }
  });
});
