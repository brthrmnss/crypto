var shelpers = require('shelpers')
var sh = shelpers.shelpers;
var PromiseHelperV3 = shelpers.PromiseHelperV3;
var express = require('express'),
    expressRest = require('express-rest');
var GenerateData = shelpers.GenerateData;
var  test = {}

var RestHelper = shelpers.RestHelper;
var Sequelize = require('sequelize')
var sequelize = null;


function MySQLAdapater(settings) {
    var self = this;
    var p = this;
    if ( settings == null ) {
        throw new Error('need settings');
    }

    self.settings = settings;

    self.dbg = {};
    //self.dbg.breakOnAdd = true;
//asdf.g
    var cfg = {}
    cfg.db = {}
    cfg.db.database = 'fileserver';
    cfg.db.user = 'root';
    cfg.db.password = 'password';
    cfg.db.port = '3306';
    if ( settings.cfg ) {
        cfg = settings.cfg;
//        asdf.g
    }


    if ( self.settings.settings != null &&
        self.settings.settings.logging == false ) {
    self.settings.logging = false
    }
    if ( self.settings.logging === false  ) {
        cfg.db.logging = self.settings.logging
    }

    //sh.exit('logging', self.settings.logging)
    self.name = settings.name;

    //cfg.db.database

    var sequelize = new Sequelize(cfg.db.database, cfg.db.user, cfg.db.password, {
        dialect: "mysql", // or 'sqlite', 'postgres', 'mariadb'
        port:    cfg.db.port, // or 5432 (for postgres)
        define: {
            timestamps: true//,
        },
        logging:cfg.db.logging
    })
    self.sequelize = sequelize

    self.defineUtils = function defineUtils() {
        self.utils = {};
        self.utilsTest = {};
        self.utils.createIt = function createIt(props){
            console.log(props.msg)
            var user = props.model.build(props.props)

            user.save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                        props.callbackRetry(props.token, props.callback)
                    }
                })

            return
        }

        self.utils.getItemIfNotDefinedRetry = function getItemIfNotDefinedRetry(props){
            props.query = sh.defaultValue(props.query, {});
            var itemName = props.model.name.toString();

            props.model.findAll(props.query).success(function(resultObj) {

                //console.log('...')

                if ( resultObj == null ) {

                    self.utils.createIt(props)


                    return
                }

                props.storeItem = sh.dv(props.storeItem, itemName)
                props.token[props.storeItem] //.user= user;
                props.callback()
            })


        }


        self.utils.search = function search(props) {
            props.query = sh.defaultValue(props.query, {});
            var itemName = props.model.name.toString();

            if ( props.limit != null ) {
                props.query.limit = props.limit;

            }
            if ( props.offset != null ) {
                props.query.offset = props.offset;
            }

            props.query.limit = sh.dv(props.query.limit, 10);
            if (props.query.where == null ) {
                var query = {}
                query.where = props.query;
                if ( props.query.limit != null ) {
                    query.limit = props.query.limit
                    delete  props.query.limit
                }
                if ( props.query.offset != null ) {
                    query.offset = props.query.offset
                    delete  props.query.offset
                }
                if ( props.query.query != null ) {
                    // var y = {}
                    var cleanedQuery = []
                    var cleanQuery = true


                    var query2 = {}
                    var andQuery = []
                    if ( props.userId != null ) {
                        andQuery.push({user_id: props.userId});
                    }
                    sh.each(props.query.query, function f(k,v) {
                        if ( k == 'limit') {
                            return;
                        }
                        if ( k == 'offset') {
                            return;
                        }
                        if ( k == 'fxResult' ) {
                            return;
                        }
                        query[k]= {};

                        var querySet = {}
                        querySet[k] = {like: "%" + v + "%"}
                        //andQuery.push({ src: {like: "%" + query.season_name + "%"} })

                        andQuery.push(querySet);

                        if ( sh.includes2(v, 'like ?')) {
                            cleanQuery = false
                        }
                    })

                    var arr =  Sequelize.and.apply(this, andQuery)

                    /*
                     sh.each(props.query.query, function f(k,v) {
                     // y.u = 'l';
                     //cleanedQuery.push( [k + ' LIKE ?', '%'+v+'%' ])

                     if ( k == 'limit') {
                     return;
                     }
                     if ( k == 'offset') {
                     return;
                     }
                     sh.tick = function surroundWithBackticks(x) {
                     return '`'+x+'`';
                     }
                     cleanedQuery.push(  sh.tick(self.settings.name)+'.'+k + ' LIKE ?'  )
                     cleanedQuery.push(   '%'+v+'%'  )
                     if ( v != null ) {
                     return;
                     }
                     if ( sh.includes2(v, 'like ?')) {
                     cleanQuery = false
                     }
                     })
                     */
                    query.where = props.query.query;
                    if ( cleanQuery ) {
                        query.where = cleanedQuery//.join(' ');
                        query.where = arr;
                    }
                }
                props.query = query;

            }
            props.callback = sh.dv(props.callback, props.cb);


            var dbAction = props.model.findAll;

            if ( props.countOnly == true ) {
                dbAction = props.model.count
            }

            //make this the model
            // dbAction.call(props.model,props.query).

            if (props.countOnly!= true) {
                props.model.findAll(props.query).success(function(resultObj) {

                    //console.log('...')

                    if ( resultObj == null ) {

                        // self.utils.createIt(props)


                        return
                    }

                    //props.storeItem = sh.dv(props.storeItem, itemName)
                    //props.token[props.storeItem] //.user= user;
                    props.callback(resultObj)
                })
            } else
            {
                props.model.count(props.query).success(function(resultObj) {

                    //console.log('...')

                    if ( resultObj == null ) {

                        // self.utils.createIt(props)


                        return
                    }

                    //props.storeItem = sh.dv(props.storeItem, itemName)
                    //props.token[props.storeItem] //.user= user;
                    props.callback(resultObj)
                })
            }



        }
    }
    self.defineUtils();



    function defineWork() {
        /**
         * Create the table definition from the settings 'field' object
         * @param token
         * @param cb
         */
        p.defineTable = function defineTable(token, cb) {
            var tableFields  = {}
            if ( self.settings.settings ) {
                var tableOptions = sh.dv(self.settings.settings.tableOptions, {});
            } else {
                var tableOptions = sh.dv(self.settings.tableOptions, {});
            }

            if (  tableOptions.timestamps == null )
                tableOptions.timestamps=true;


            var DataTypes = Sequelize;
            tableFields=  {
                id:{ type: DataTypes.INTEGER(10),
                    allowNull: false,
                    primaryKey:true,
                    autoIncrement:true}
            }

            sh.each( token.settings.createFields, function addField(k,v ) {

                //blank
                if ( v == null || v === "" ) {
                    tableFields[k] = {
                        type: DataTypes.STRING
                        // allowNull: false,
                    }
                    return;
                }
                if (  v == "text" ) {
                    tableFields[k] = {
                        type: DataTypes.TEXT()
                        // allowNull: false,
                    }
                    return;
                }
                if ( v == true ) {
                    tableFields[k] = {
                        type: DataTypes.BOOLEAN
                    }
                    return;
                }
                if ( v == "date" || v.getTime != null ) {
                    tableFields[k] = {
                        type: DataTypes.DATE
                    }
                    return;
                }
                if (v.hasOwnProperty('_typeName')) {
                    tableFields[k] = v
                } else {
                    if (v.type == 0 || v == 0  ) {
                        v = {
                            type: DataTypes.INTEGER(10)
                        }
                        //v.type = DataTypes.INTEGER(10);
                    }
                    if ( v.type == true  ) {
                        v = {
                            type: DataTypes.BOOLEAN()
                        }
                    }
                    tableFields[k] = v
                }
            })
            /*

             name: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             fileName: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             path: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             category: {
             type: DataTypes.STRING,
             allowNull: true,
             },
             type: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             */
            /*updatedDate: {
             type: DataTypes.DATE,
             allowNull: false,
             defaultValue: 'CURRENT_TIMESTAMP'
             },*//*

             isDeleted: {
             type: DataTypes.BOOLEAN,
             allowNull: true,
             defaultValue: '0'
             }
             */

            var Table =  null;
            function newTableDefinition (sequelize, DataTypes) {
                console.error(tableOptions)
                return sequelize.define(token.settings.name, tableFields, tableOptions)
            };

            Table = newTableDefinition(sequelize,Sequelize);

            self.Table = Table;
            cb();
            return;
        }
        p.connectToDb = function connectToDb(token, cb) {
            sequelize
                .authenticate()
                .then(function(err) {
                    if (!!err) {
                        console.log('Unable to connect to the database:', err, err.stack)
                    } else {
                        console.log('Syced successfully.')
                        cb();
                    }
                })

        }
        p.syncDatabaseDefintion = function syncDatabaseDefintion(token, cb) {
            sequelize.sync({force: true}).then(function (err) {
                if (!!err) {
                    console.log('Unable to sync the database:', err, err.stack)
                } else {
                    console.log('Connection has been established successfully.')
                    cb();
                }
            });
            return;


        }

        p.getUser = function getUser(token, cb) {
            self.utils.getItemIfNotDefinedRetry(
                {
                    model:User,
                    props:{
                        username: 'user1',
                        password: "password",
                        email: "user@user.com",
                        token: "234234"
                        //  password: generatePasswordHash('i-am-so-great')
                    },
                    msg:'User does not exists...',
                    callback:cb,
                    token:token,
                    callbackRetry:self.getUser
                }

            )


            return;
            User.find({}).success(function(user) {

                // project will be an instance of Project and stores the content of the table entry
                // with id 123. if such an entry is not defined you will get null
                console.log('...')

                if ( user == null ) {

                    self.utils.createIt(
                        {
                            model:User,
                            props:{
                                username: 'user1',
                                password: "password",
                                email: "user@user.com",
                                token: "234234"
                                //  password: generatePasswordHash('i-am-so-great')
                            },
                            msg:'User does not exists...',
                            callback:cb,
                            token:token,
                            callbackRetry:self.getUser
                        }
                    )

                    console.log('user was null...')
                    var user = User.build({
                        username: 'user1',
                        password: "password",
                        email: "user@user.com",
                        token: "234234"
                        //  password: generatePasswordHash('i-am-so-great')
                    })

                    user.save()
                        .complete(function(err) {
                            if (!!err) {
                                console.log('The instance has not been saved:', err)
                            } else {
                                console.log('We have a persisted instance now')
                                self.getUser(token, cb)
                            }
                        })

                    return
                }


                token.user= user;
                cb()
            })

        }
        p.getContent = function getContent(token, cb) {
            Content.find({}).success(function(content) {
                // project will be an instance of Project and stores the content of the table entry
                // with id 123. if such an entry is not defined you will get null
                console.log('...')
                if ( content == null ) {
                    console.log('content null...')
                    var content = Content.build({
                        name: 'Test Content',
                        fileName: "hhh.txt",
                        path :"D",
                        type: "type?"
                        //  password: generatePasswordHash('i-am-so-great')
                    })

                    content.save()
                        .complete(function(err) {
                            if (!!err) {
                                console.log('The instance has not been saved:', err)
                            } else {
                                console.log('We have a persisted instance now')
                                self.getContent(token, cb)
                            }
                        })

                    return
                }
                token.content= content;
                cb()
            })

        }
        p.createUserContent = function createUserContent(token, cb) {
            var userContent = UserContents.build({
                clientIP: 'john-doe',
                //  password: generatePasswordHash('i-am-so-great')
            })


            userContent.setContent(token.content)
            userContent.setUser(token.user)
            //sdfgdf.d
            cb();
            return
            userContent
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                    }
                })
        }

        p.createContent = function createContent(token, cb) {
            var newItem = self.Table.build({
                name: 'john-doe',
                //  password: generatePasswordHash('i-am-so-great')
            })


            if ( self.dbg.breakOnAdd ) {
                asdf.g
            }
            //userContent.setContent(token.content)
            //userContent.setUser(token.user)
            newItem
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        cb();
                        self.newItem = newItem;
                        token.id = newItem.dataValues.id;
                        console.log('We have a persisted instance now')
                    }
                })

            return
            userContent
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                    }
                })
        }

        p.readContent = function readContent(token, cb) {
            self.utils.search({model:self.Table,
                    callback:function(results){
                        console.log('results', results.length);
                        if ( results.length != 1 ) {
                            throw new Error('ugggg')
                        }
                        cb();
                    }, query :{where:{id:1}}
                }
            )

        }

        p.updateContent = function updateContent(token, cb) {

            self.utils.local={}
            self.utils.local.search = function search(props) {
                self.utils.search({model: self.Table,
                        callback: function (results) {
                            console.log('results', results.length);
                            if (results.length != 1 &&  props.throwErrorIfEmpty==true) {
                                throw new Error('ugggg')
                            }
                            props.cb(results)
                        }, query: {where: props.query}
                    }
                )

            }

            var newName = 'newNAme6'

            self.utils.local.search( {
                    query:{id:1},
                    cb:doUpdate
                }
            )
            function doUpdate(results) {

                var result = results[0];
                result.updateAttributes({name:newName})
                    .complete(function(err) {
                        if (!!err) {
                            console.log('The instance has not been saved:', err)
                        } else {
                            console.log('doUpdate', 'We have a persisted instance now')
                            testNameUpdate()
                        }
                    })
                // cb();
            }



            function testNameUpdate() {
                self.utils.local.search( {
                        query:{id:1},
                        cb:testName
                    }
                )
                function testName(results) {
                    var result = results[0];
                    if ( result.dataValues.name != newName ) {
                        throw new Error('did not update the name ... to ' +newName)
                    }
                    cb();
                }

            }

        }

        p.deleteContent = function deleteContent(token, cb) {

            var newName = 'newNAme6'

            self.utils.local.search( {
                    query:{id:1},
                    cb:deleteItem
                }
            )
            function deleteItem(results) {
                var result = results[0];
                result.destroy().complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been destroyed:', err)
                    } else {
                        console.log('destroyed')
                        testDestroy();
                    }
                })

            }

            function testDestroy() {
                self.utils.local.search( {
                        query:{id:1},
                        cb:testDestroy_
                    }
                )
                function testDestroy_(results) {
                    var result = results[0];
                    if ( results.length != 0  ) {
                        throw new Error('did not destroy the item ');// the name ... to ' +newName)
                    }
                    cb();
                }

            }

        }




        p.listContent = function listContent(token, cb) {

            self.utils.search( {
                    model:self.Table,
                    query:{},
                    cb:list,
                    limit:10,
                }
            )
            function list(results) {
                var json = []
                sh.each(results, function addToResults(k,v){
                    json.push(v.values)
                });


                cb()
                return;

            }

        }



        self.bulkAdd = function bulkAdd(results, cb) {



            if ( self.dbg.breakOnAdd ) {
                sh.x('breakonadd', results)
                asdf.g


            }

            self.Table.bulkCreate(results).then(
                function(results) {
                    // Notice: There are no arguments here, as of right now you'll have to...
                    if ( cb != null ) cb(results);
                    return;
                    /*self.Table.findAll().then(function(users) {
                     //  console.log(users) // ... in order to get the array of user objects
                     })

                     self.Table.findAll({ where: ["name LIKE ?", "%1%"] }).then(function(users) {
                     console.log('h',users) // ... in order to get the array of user objects
                     })
                     return
                     self.Table.findAll({where:{name:{$like:'5'}}}).then(function(users) {
                     console.log('h',users) // ... in order to get the array of user objects
                     })*/
                }).catch(function (err) {
                console.log(err)
                // exit();
                setTimeout(function() {
                    throw err;
                },5)


            });
        }
    }
    defineWork()


    function defineAPI() {
        self.fxGet =  function getRecord(req, rest) {
            self.getId(req.params.id, function onGotRecord(record)
            {
                if (record) rest.ok(record);
                else rest.notFound();
            }, self.userId(req));

        };

        self.userId = function userId(req, fx) {
            if ( self.settings.fxUserId== null ) {
                return null;
            }
            var userId = self.settings.fxUserId(req)
            if ( fx != null && sh.isFunction(fx) ) {
                fx(userId);
                return userId
            }
            if ( fx != null && sh.isObject(fx) ) {
                fx.user_id = userId;
            }
            return userId
        }

        self.fxCreate =  function createRecord(req, rest, body ) {
            // self.userId(function(userId){body.user_id=userId})
            self.userId(req, body)


            if ( self.dbg.breakOnAdd ) {
                sh.x('breakonadd', results)
                asdf.g


            }
           // console.log('creating an item fxCreate createRecord', body)
            //sh.exit('why u here?')

            var user = self.Table.build(body)

            user.save().success(function(o) {

                //not in Rest HTTP Spec, but xhr ignores location header on
                //rest values
                rest.created('/api/'+self.name+'/' + o.dataValues.id,
                    o.dataValues.id);

            })
                .complete(function(err) {
                    if (!!err) {
                        var debugItem = body;
                        //asdf.ggggggg
                        self.proc('The instance has not been saved:', err)
                        console.error(err.stack)
                    } else {
                        if ( self.settings.settings != null &&
                            self.settings.settings.logging == false ) {
                            //self.proc('...')

                        }
                        else {
                            self.proc('We have a persisted instance now')
                        }
                        //   props.callbackRetry(props.token, props.callback)
                    }

                })

            return;
        };


        self.fxUpdate =  function updateRecord(req, rest, body ) {
            self.getId(
                body.id, function postUpdateAction(object) {
                    var to = object;
                    if ( to == null ) {
                        var msg =('could not find id ' + body.id)
                        console.error(msg)
                        //rest.statusCode = 404;
                        // rest.send(msg)
                        rest.notFound('Error: record does not exist' +
                            'Error: could not find id ' + body.id)
                        return;
                    }
                    self.utils.updateItem(body, to, function saved() {
                        return rest.accepted('/api/' + self.name + '/' + encodeURI(body.id) ,body.id);
                    })
                },self.userId(req));

        };


        self.fxDelete =  function fxDelete(req, rest, id ) {
            self.getId(
                id, function o(result) {
                    if ( result == null) {
                        //throw new Error ('not found')
                        rest.notFound('Error: record does not exist' +
                            'Error: could not find id ' + id)
                        return;
                    }
                    result.destroy().complete(function(err) {
                        if (!!err) {
                            console.log('The instance has not been destroyed:', err)
                        } else {
                            console.log('destroyed')
                            rest.gone();
                        }
                    })
                }, self.userId(req))

        };


        self.fxList = function fxList(req, rest, h) {
            //rest.ok(self.records);
            self.fxSearch(req, rest, h);
        }

        self.fxCount = function fxCount(req, rest, h) {
            if ( h == null ) { h= {};}
            self.fxSearch(req, rest, h);
        };

        self.fxSearch = function fxSearch(req, rest, h) {
            if (h.query == null ) {
                var query = {}
                var skipProps = ['limit']
                sh.each(h, function copyPropsToQuery(k,v){
                    if ( sh.includes(skipProps, k) ){
                        return;
                    }
                    query[k] = v;
                })

                h.query = {}
                h.query.query = query;

            }
            /*if ( req.userId != null ) {
             //asdf.g
             if (h.query == null ) {
             h.query = {}
             }
             h.query.user_id = req.userId;
             }*/
            //to ensure we can see req.session
            if ( req.session == null && req.req != null ) {
                req = req.req;
            }
            var countOnly = req.url.indexOf('/count') != -1
            self.utils.search( {
                    model:self.Table,
                    query: h.query,
                    cb:list,
                    limit: h.limit,
                    offset: h.offset,
                    userId:self.userId(req),
                    countOnly:countOnly
                }
            )

            function list(results) {
                if ( countOnly != true ) {
                    var json = []
                    sh.each(results, function addToResults(k, v) {
                        json.push(v.values);
                    });
                } else {
                    json = results; //the count
                }
                if (h.fxResult != null ) {
                    h.fxResult(results);
                    return;
                }
                rest.ok(json);
            }
        }


        self.cb = function blankCallback() {

        }

        self.resetDp = function resetDp(fxResetCallback) {
            var token = {};
            token.settings = {}//sh.clone(self.settings);
            token.settings.name = self.settings.name;
            token.settings.createFields = self.settings.fields;

            self.defineTable(token, self.cb);

            var opts = {}
            if ( self.settings.reset == true ) {
                opts = {force: true}
            }
            sequelize.sync(opts).then(function (results) {
                if (results.err != null ) {
                    console.log('Unable to sync the database:', err, err.stack)
                } else {
                    console.log('Connection has been established successfully.')



                    function addDataIfNeeded() {
                        self.Table.destroy({where:{}}).then(function() {
                            self.bulkAdd(self.settings.fxReset(), fxResetCallback);
                        })

                    };

                    if ( self.settings.reset == true ) {
                        addDataIfNeeded()
                    } else {
                        if ( self.settings.genData == RestHelper.types.GenDataIfEmpty ) {
                            self.utils.getLength(function isLength0(length){
                                if ( length == 0 ) {
                                    self.bulkAdd(self.settings.fxReset(), fxResetCallback);
                                } else {
                                    fxResetCallback();
                                }
                            })


                            return;
                        }
                        fxResetCallback();
                    }






                    // cb();
                }
            }).catch(function (err) {
                console.log(err)
                // exit();
                return;
                setTimeout(function() {
                    throw err;
                },3000)


            });
            return;


        }

        self.utils.getLength = function getLength(fxCallback) {

            self.Table.count({}).then(function(count) {
                fxCallback(count)
            })
            return;


        }


        self.utils.empty = function empty(fxCallback) {
            self.Table.destroy({where:{}}).success(function() {
                fxCallback()
            })
            return;


        }


        p.getId = function getId(id, cb, userId) {
            if (userId != null ) {
                id = {id:id}
                id.user_id = userId;
                id = {where:id};
            }
            self.Table.find(id).success(function(result) {
                cb(result)
            })
        }


        p.utils.updateItem = function updateItem(from, to, cb, silentNoDbg) {
           // console.log('s', silentNoDbg, self.settings.logging)
           // sh.exit()
            //asdf.g
            to.updateAttributes(from)
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        if ( self.settings.logging != false  && silentNoDbg != true )
                        console.log('updateItem', 'We have a persisted instance now')
                        sh.callIfDefined(cb)
                        //cb()
                    }
                })

        }



    }
    defineAPI();

    p.proc = function proc() {
        sh.sLog(arguments)
    }


}






function RestHelperSQLTest() {
}

RestHelperSQLTest.RestHelper = RestHelper;
RestHelperSQLTest.createHelper = function createHelper(name, server, settings){
    var tasks = new RestHelper();
    var taskApiSettings = {}
    taskApiSettings = sh.dv(settings.sql, {})
    var initTasks = [];
    initTasks.push({id: 0, name: 'Complete Car'})
    initTasks.push({id: 1, name: 'Complete House'})
    taskApiSettings.model = initTasks
    taskApiSettings.name = 'tasks'
    //taskApiSettings.name = 'breadcrumbs'
    taskApiSettings.name = name;

   console.log('fields', settings.fields)
    taskApiSettings.file = 'rest_helper/tasks.json'
    taskApiSettings.file = 'rest_helper/'+name+'.json'

    var tS = taskApiSettings;
    tS.createGetPostRoutes = true;
    tS.requiredFields = {}
    tS.reset = false;
    //tS.reset = true;
    tS.server = server
    console.log('..............', server)
    tS.sql = true

    /*if ( tS.fxUserId == null ) {
     tS.fxUserId = function fxUserId() {
     return null
     };
     }*/
    tS.fields = {name: "", desc: "", user_id: 0, content_id: 0}





    tS.fxReset = function fxReset() {
        GenerateData = shelpers.GenerateData;
        var gen = new GenerateData();
        var model = gen.create(100, function (item, id, dp) {
            item.name = id;
            // item.id = id;
            item.desc = GenerateData.getName();
        });

        return model;
    }


    sh.mergeObjectsForce(settings, tS);


    if ( settings.noSQL != true ) {
        tS.actor = new MySQLAdapater(tS);
    };

    tasks.loadRest(taskApiSettings);
    if ( tS.actor ) {
        tasks.sequelize = tS.actor.sequelize;
        tasks.Table = tS.actor.Table;
    }
    return tasks;
}


RestHelperSQLTest.MySQLAdapater  = MySQLAdapater;
RestHelperSQLTest.Sequelize  = Sequelize;

exports.RestHelperSQLTest = RestHelperSQLTest





if ( module.parent == null ) {

    var express = require('express'),
        expressRest = require('express-rest');

    var app = express();
    //var cors = require('cors')
    //CORS middleware
    var allowCrossDomainMiddlware = function allowCrossDomainMiddlware (req, res, next) {
        res.header('Access-Control-Allow-Origin', 'example.com');
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type');

        next();
    }


    var tasks = new RestHelper();
    var taskApiSettings = {}
    var initTasks = [];
    initTasks.push({id: 0, name: 'Complete Car'})
    initTasks.push({id: 1, name: 'Complete House'})
    taskApiSettings.model = initTasks
    taskApiSettings.name = 'tasks'
    taskApiSettings.name = 'breadcrumbs'
    taskApiSettings.file = 'rest_helper/tasks.json'
    var tS = taskApiSettings;
    tS.createGetPostRoutes = true;
    tS.requiredFields = {name: ""}
    tS.reset = false;
    tS.reset = true;
    tS.server = app
    tS.sql = true


    tS.fields = {name: "", desc: "", user_id: 0, content_id: 0}
    tS.actor = new MySQLAdapater(tS);


    tS.fxReset = function fxReset() {
        GenerateData = shelpers.GenerateData;
        var gen = new GenerateData();
        var model = gen.create(100, function (item, id, dp) {
            item.name = id;
            // item.id = id;
            item.desc = GenerateData.getName();
        });

        return model;
    }
    tasks.loadRest(taskApiSettings)


    app.use(function (req, res, next) {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
        next();
    })
    //app.use(cors())
    app.use(allowCrossDomainMiddlware);
    app.listen(5002);


    var TestHelper = shelpers.TestHelper;
    var reqPost = TestHelper.reqPost;


    var self = {}
    self.settings = {}
    self.settings.port = 5002;

    var types = {};
    types.POST = 'POST'
    types.GET = 'GET'
    types.PUT = 'PUT'

    types.errors = {}
    types.errors.recordDoesNotExist = 'Error: record does not exist'

    function testRestHelper() {
        self.quickRequest = function quickRequest(url, method, fx, postData, doRegPost) {
            if (method == null) {
                method = types.GET
            }
            var reqoptions = {}
            reqoptions.url = 'http://localhost:' + self.settings.port + '/' + url
            if (postData == null) {
                postData = {}
            }
            if (method == types.POST || method == types.PUT) {
                if (doRegPost) {
                    reqoptions.form = postData
                } else {
                    //reqoptions.json = true
                    //reqoptions.body = "gg"
                    reqoptions.json = true
                    reqoptions.body = postData
                }
            } else {
                reqoptions.qs = postData
            }

            reqoptions.method = method
            reqoptions.showBody = true;
            reqoptions.fx2 = function storeContents(body, resp) {
                console.log(reqoptions.url, 'test ok...')
                try {
                    body = JSON.parse(body)
                } catch (e) {

                }
                if (fx) {
                    fx(body, resp)
                }
            };
            reqoptions.name = 'test ' + sh.paren(url)
            console.log('testing...')
            reqPost(reqoptions)
        }


        var verbs = {}
        verbs.actions = {}
        verbs.isJSON = 'isJSON'
        verbs.hasXResults = function hasXResults(amt) {


        }
        //has(6).results()
        //create task
        //list tasks
        //show all tasks
        //create task via put
        //create task


        /*

         new Verb().has(6).isJSON
         json.length == 6

         */


        var token = {}
        var work = new PromiseHelperV3();
        token.silentToken = true
        work.wait = token.simulate == false;
        work.startChain(token);//
        /* */
        /*           .add(self.searchByName)
         .log()
         .add(self.getFirstQuery)
         .add(self.convertMagnetLinkToTorrent)
         .log()
         .add(self.returnMagnetLink)*/
        /*
         .add(self.testGet)
         .add(self.get_create)
         .end();*/


        var data = {}
        data.expectedRecordLength = 100;//tasks.utils.getLength(); //tasks.records.length;
        data.checkRecordSize = function checkRecordSize() {
            return  tasks.lastLength == data.expectedRecordLength
        }
        data.addItem = function addItem() {
            data.expectedRecordLength++;
        }
        data.removeItem = function removeItem() {
            data.expectedRecordLength--;
        }

        data.bodyHasError = function bodyHasError(bodyResponse) {
            if (sh.startsWith(bodyResponse, 'Cannot')) {
                return true;
            }
            return  sh.includes(bodyResponse, 'Error')
        }

        data.isFailure = function isFailure(resp) {
            return resp.statusCode == 404
        }


        function assert(eq, msg) {
            if (eq == false) {
                throw new Error(msg);
            }
        }


        function testUtilLinks() {
            self.reset = function reset(token, cb) {
                if (tasks.busy == true) {
                    //asdf.g.ds
                    work.tryLater();
                    return;
                    //setTimeout(self.reset, 500)
                }
                taskApiSettings.model = []
                GenerateData = shelpers.GenerateData;
                var gen = new GenerateData();
                /*taskApiSettings.model = gen.create(100, function (item, id, dp){
                 item.name = id;
                 item.id = id;

                 item.desc = GenerateData.getName();
                 })*/
                tasks.utils.empty(function onTableCleared() {
                    tasks.resetDp(function doneReset() {
                        data.expectedRecordLength = 100;
                        cb();
                    })
                })
                ;
                // assert(data.checkRecordSize(), 'did not reset')
            }

            self.getLength = function getLength(token, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    data.expectedRecordLength = length;
                    cb();
                })

            }

            self.checkRecordSize = function checkRecordSize(token, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    data.expectedRecordLength = length;
                    assert(data.checkRecordSize(), 'did not reset')
                    cb();
                })
            }

            /**
             * Checks record size, if fails assert, returns message
             * @param msg
             * @param cb
             */
            self.checkSize = function checkSize(msg, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    //data.expectedRecordLength = length;
                    assert(data.checkRecordSize(), msg + [tasks.lastLength , data.expectedRecordLength].join(','))
                    cb();
                })
            }


        }

        testUtilLinks();


        function testFauxGetRoutes() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);


            self.testGet = function testGet(token, cb) {
                self.quickRequest('api/' + tS.name , 'get', result, {id: "6"})
                function result(body) {
                    //return;
                    // tasks.showId(0, 'lll');
                    assert(body.id==6, 'did not reset')
                    cb();
                }
            }
            //work.add(self.testGet);


            self.get_create = function get_create(token, cb) {
                self.quickRequest('api/' + tS.name + '/create', 'get', result, {name: "randomTask"})
                data.addItem();
                function result() {
                    self.checkSize( 'did not add task properly', cb)
                    //cb();
                }
            }
            work.add(self.get_create);


            self.get_update = function get_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 3;
                self.quickRequest('api/' + tS.name + '/update', 'get', result,
                    {id: idToUpdate, name: newName})
                function result() {
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.get_update);


            self.get_update = function get_create(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 4;
                self.quickRequest('api/' + tS.name + '/update', 'get', result,
                    {id: idToUpdate, name: newName})
                function result() {
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.get_update);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/update', 'get', result, {id: -1, name: newName})
                function result(body) {
                    var ok =  sh.includes(body, types.errors.recordDoesNotExist);
                    assert(ok,
                        'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.get_delete = function get_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                self.quickRequest('api/' + tS.name + '/delete', 'get', result,
                    {id: 8, name: newName})
                function result(body) {
                    self.checkSize(
                        'did not delete task properly', cb)
                    //cb();
                }
            }
            work.add(self.get_delete);

            self.get_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                // data.removeItem()
                self.quickRequest('api/' + tS.name + '/delete/' + -1, 'get',
                    result, {id: -1, name: newName})
                function result(body) {
                    var ok = data.bodyHasError(body)
                    assert(ok,
                        'did not delete task properly broken');
                    self.checkSize(
                        'did not delete task properly', cb)
                }
            }
            work.add(self.get_delete_with_id_broken);


            self.get_delete_with_id = function get_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize(
                        'did not delete task properly', cb)
                }
            }
            work.add(self.get_delete_with_id);

        }


        testFauxGetRoutes();


        function testRestRoutes() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);


            self.testRestGet = function testRestGet(token, cb) {
                var itemId = 1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body.id == itemId, 'did not get item')
                    cb();
                }
            }
            work.add(self.testRestGet);


            self.rest_create = function rest_create(token, cb) {
                // adsf.g.d
                self.quickRequest('api/' + tS.name, 'POST', result, {name: " rand task"})
                data.addItem();
                function result(body) {
                    self.checkSize('did not add task properly', cb);
                    //assert(data.checkRecordSize(), 'did not add task properly')
                    // ();
                }
            }
            work.add(self.rest_create);


            self.rest_create_upsert_fail = function rest_create(token, cb) {
                self.quickRequest('api/' + tS.name, 'POST', result,
                    {name: " rand task2__",upsertQuery:{desc:"<><>"} })
                data.addItem();
                function result(body) {
                    //self.proc('what?...')
                    console.log('what?...');
                    self.checkSize('upsert, did not add task properly', cb);
                }
            }
            work.add(self.rest_create_upsert_fail);


            self.rest_create_upsert_2 = function rest_create(token, cb) {
                self.quickRequest('api/' + tS.name, 'POST', result,
                    {name: " rand task2",upsertQuery:{name:" rand task2"} })
                //data.addItem();
                function result(body) {
                    //self.proc('what?...')
                    console.log('what?...');
                    self.checkSize('upsert, why did you add tag?', cb);
                }
            }
            work.add(self.rest_create_upsert_2);

            //work.add(self.getLength);
            //work.add(self.checkRecordSize);
            //


            self.rest_update = function rest_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 1
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'PUT', result, {id: idToUpdate, name: newName})
                function result() {

                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })



                }
            }
            work.add(self.rest_update);


            self.rest_update_wrong = function rest_update_wrong(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + 9999, 'get', result, {id: 0, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not add task properly')
                    cb();
                }
            }
            //work.add(self.rest_update_wrong);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + "-1", 'get', result, {id: -1, name: newName})
                function result(body, resp) {
                    assert(data.isFailure(resp), 'Updaded invalid id')
                    // assert(sh.includes(body, types.errors.recordDoesNotExist),
                    //     'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.rest_delete = function rest_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                var deleteId = 1;
                self.quickRequest('api/' + tS.name + '/' + deleteId, 'DELETE', result)
                function result(body) {


                    self.checkSize(    'did not delete task properly', cb )
                    //assert(data.checkRecordSize(),
                    //   'did not delete task properly')
                    //cb();
                }
            }
            work.add(self.rest_delete);

            self.rest_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/delete/' + 6, 'DELETE', result)
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    //assert(data.checkrecordsize(),
                    //    'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.rest_delete_with_id_broken);


            self.rest_delete_with_id = function rest_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize(    'did not delete task properly', cb )
                }
            }
            work.add(self.rest_delete_with_id);

            self.rest_list = function rest_list(token, cb) {
                self.quickRequest('api/' + tS.name, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize( 'did not delete task properly', cb )
                }
            }
            work.add(self.rest_list);
        }

        testRestRoutes();

        /*

         self.quickRequest('api/'+tS.name+'/update', 'get', null, {id:0, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/update', 'get', null, {id:-1, name:"randomTask_@"})

         self.quickRequest('api/'+tS.name+'/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/delete', 'get', null, {id:-1, name:"randomTask_@"})


         //l crud//
         self.quickRequest('api/tasks', 'get', null, {user_id:"6"})
         self.quickRequest('api/tasks', 'put', null, {name:"randomTask"})
         self.quickRequest('api/'+tS.name+'/1', 'get', null )
         self.quickRequest('api/'+tS.name+'/1', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/1', 'delete', null )

         self.quickRequest('api/'+tS.name+'/search', 'get', null, {id:-1, name:"randomTask", __limit:1})
         self.quickRequest('api/'+tS.name+'/search', 'get', null, {id:1, name:"randomTask", __limit:1, __exact:true})


         self.quickRequest('api/'+tS.name+'/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/delete', 'get', null, {id:-1, name:"randomTask_@"})
         */


        function testSearchRoute() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);

            function defineTestSearch() {


                self.testQuerySearch = function testQuerySearch(token, cb) {
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query://{name:{$like: '%hat'}
                            ["name LIKE ?", "%1%"]
                            //}
                        })
                    //{query:{name:{$like:'%1%'}}} )
                    function result(body) {
                        assert(body.length == 10, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch);


                self.testQuerySearch_limit = function testQuerySearch(token, cb) {
                    //self.quickRequest('api/'+tS.name+'/search', 'get', result, {query:{name:1}, limit:10} )
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query://{name:{$like: '%hat'}
                            ["name LIKE ?", "%1"]
                            //}
                        })
                    function result(body) {
                        assert(body.length == 10, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit);


                self.testQuerySearch_limit_1 = function testQuerySearch(token, cb) {
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query: {name: 11}, limit: 10})
                    function result(body) {
                        assert(body.length == 1, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_1);


                self.changeDescOnItem = function changeDescOnItem(token, cb) {
                    tasks.getId(11, function onGot(item) {
                        token.item = item;
                        token.newDesc = "Find Desc"


                        tasks.utils.updateItem({desc: "Find Desc"}, item, function onSaved(o) {
                            cb();
                        });


                    })
                }
                work.add(self.changeDescOnItem);

                //return

                self.testQuerySearch_limit_piecemeal = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc'
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "10", desc: token.newDesc})
                    function result(body) {
                        assert(body.length == 1, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_piecemeal);

                self.testQuerySearch_limit_piecemealb = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc';
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "11", desc: tasks.getId(11).desc.slice(0, 6)})
                    function result(body) {
                        assert(body.length == 1, 'search doesn\'t work on wild cards');
                        cb();
                    }
                }
                //  work.add(self.testQuerySearch_limit_piecemealb);

                self.testQuerySearch_limit_piecemealb_findNone = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc';
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "11", desc: 'llll'})
                    function result(body) {
                        assert(body.length == 0, 'search return more than 0 results for bad query');
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_piecemealb_findNone);

            }

            defineTestSearch()






            //crud

            /* setTimeout(function () {
             tasks.showId(0, 'lll');
             }, 500)*/

        }


        testSearchRoute();




        function testUserId(){
            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);



            self.setupUserIdTesting = function setupUserIdTesting(token, cb) {
                tS.fxUserId = function getUserId(req){
                    return 4;
                }

                cb();

            }
            work.add(self.setupUserIdTesting);

            self.testUpdateToUserId = function testUpdateToUserId(token, cb) {

                var idToUpdate = 1

                tasks.getId(idToUpdate, function onGot(item) {

                    tasks.utils.updateItem({user_id:4}, item, cb2)

                    function cb2(o) {
                        cb();
                    }
                    //assert(item.dataValues.name == newName, 'did not restfully update task properly')
                    //cb();
                })


            }
            work.add(self.testUpdateToUserId);


            self.testRestGet = function testRestGet(token, cb) {
                var itemId = 1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body.id == itemId, 'did not get item')
                    cb();
                }
            }
            work.add(self.testRestGet);

            self.testRestGet_BadUserId = function testRestGet(token, cb) {
                var itemId = 1+1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body == '', 'return item from get you should not have')
                    cb();
                }
            }
            work.add(self.testRestGet_BadUserId);


            self.rest_create = function rest_create(token, cb) {
                // adsf.g.d
                self.quickRequest('api/' + tS.name, 'POST', result, {name: " rand task"})
                data.addItem();
                function result(body) {
                    self.checkSize('did not add task properly', cb);
                    //assert(data.checkRecordSize(), 'did not add task properly')
                    // ();

                    //list and get last id?
                }
            }
            work.add(self.rest_create);


            self.rest_update = function rest_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 1
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'PUT', result, {id: idToUpdate, name: newName})
                function result() {

                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })



                }
            }
            work.add(self.rest_update);


            self.rest_update_wrong = function rest_update_wrong(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 8
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'get', result, {id: 0, name: newName})
                function result() {
                    tasks.settings.userId = null;
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name != newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.rest_update_wrong);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + "-1", 'get', result, {id: -1, name: newName})
                function result(body, resp) {
                    assert(data.isFailure(resp), 'Updaded invalid id')
                    // assert(sh.includes(body, types.errors.recordDoesNotExist),
                    //     'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.rest_delete = function rest_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                var deleteId = 1;
                self.quickRequest('api/' + tS.name + '/' + deleteId, 'DELETE', result)
                function result(body) {


                    self.checkSize(    '__did not delete task properly', cb )
                    //assert(data.checkRecordSize(),
                    //   'did not delete task properly')
                    //cb();
                }
            }
            work.add(self.rest_delete);

            self.rest_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/delete/' + 6, 'DELETE', result)
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    //assert(data.checkrecordsize(),
                    //    'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.rest_delete_with_id_broken);


            self.rest_delete_with_id = function rest_delete_with_id(token, cb) {
                //data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize(    'did not delete task properly', cb )
                }
            }
            work.add(self.rest_delete_with_id);

            self.rest_list = function rest_list(token, cb) {
                self.quickRequest('api/' + tS.name, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize( 'did not delete task properly', cb )
                }
            }
            work.add(self.rest_list);
        }

        testUserId();
    }

    testRestHelper();
    //setTimeout(testRestHelper, 5000); //wait for db to create records

}

