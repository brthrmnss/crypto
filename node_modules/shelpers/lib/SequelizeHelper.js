/**
 * Created by user on 4/24/15.
 * Help create a seuqlize object
 */

var shelpers = require('shelpers');
var sh = shelpers.shelpers;
var EasyRemoteTester = shelpers.EasyRemoteTester;
var Sequelize = require('sequelize');
var SettingsHelper = shelpers.SettingsHelper;

function SequelizeHelper() {



}

SequelizeHelper.convertFieldsIntoDatabase = function convertFieldsIntoDatabase() {
    var tableFields  = {};
    var tableOptions = {};
    tableOptions.timestamps=true;


    var DataTypes = Sequelize;
    tableFields=  {
        id:{ type: DataTypes.INTEGER(10),
            allowNull: false,
            primaryKey:true,
            autoIncrement:true}
    }

    sh.each( token.settings.createFields, function addField(k,v ) {

        //blank
        if ( v == null || v == "" ) {
            tableFields[k] = {
                type: DataTypes.STRING
                // allowNull: false,
            }
            return;
        }
        if ( v == true ) {
            tableFields[k] = {
                type: DataTypes.BOOLEAN
            }
            return;
        }
        if (v.hasOwnProperty('_typeName')) {
            tableFields[k] = v
        } else {
            if (v.type == 0 || v == 0  ) {
                v.type = DataTypes.INTEGER(10);
            }
            if ( v.type == true  ) {
                v.type = DataTypes.BOOLEAN
            }
            tableFields[k] = v
        }
    })
    /*

     name: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     fileName: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     path: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     category: {
     type: DataTypes.STRING,
     allowNull: true,
     },
     type: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     */
    /*updatedDate: {
     type: DataTypes.DATE,
     allowNull: false,
     defaultValue: 'CURRENT_TIMESTAMP'
     },*//*

     isDeleted: {
     type: DataTypes.BOOLEAN,
     allowNull: true,
     defaultValue: '0'
     }
     */

    var Table =  null;
    function newTableDefinition (sequelize, DataTypes) {
        return sequelize.define(token.settings.name, tableFields, tableOptions)
    };

    Table = newTableDefinition(sequelize,Sequelize);

    self.Table = Table;
}

/**
 * Creates a sql object from config
 * @param settings
 * @returns {Sequelize}
 */
SequelizeHelper.createSQL = function createSQL(settings){
    var cfg = {}
    cfg.db = {}
    cfg.db.database = 'fileserver';
    cfg.db.user = 'root';
    cfg.db.password = 'password';
    cfg.db.port = '3306';

    if ( settings != null ) {
        if ( settings.database != null ){
            cfg.db = settings;
        }
    }

    cfg.db.logging = sh.dv(cfg.db.logging, true)/// = '3306';
    //cfg.db.database

    var sequelize = new Sequelize(cfg.db.database, cfg.db.user, cfg.db.password, {
            dialect: "mysql", // or 'sqlite', 'postgres', 'mariadb'
            port: cfg.db.port, // or 5432 (for postgres)
            define: {
                timestamps: true//,
            } ,
            logging: cfg.db.logging
        }
    );


    sequelize
        .authenticate()
        .then(function(err) {
            if (!!err) {
                console.log('Unable to connect to the database:', err, err.stack)
            } else {
                console.log('Synced successfully.')
                sh.callIfDefined(settings.cb, sequelize);
            }
        })


    return sequelize;
}
SequelizeHelper.updateDatabase = function updateDatabase(settings) {
    var self = this;
    //var settings = SettingsHelper.ifSettings(force, settings)
    //only overide null properties
    self.settings = SettingsHelper.mergeSettings(settings, self.settings)

    //params we utilize
    SettingsHelper.param(self.settings, 'fxDone', 'called when updateDatabase complete');
    SettingsHelper.param(self.settings, 'sequelize', 'do not use template db 3306 user/password');

    var t = EasyRemoteTester.create('recipe to sync table', {fxDone:self.settings.fxDone});
    t.makeTest();
    /*t.test.defineTable = function defineTable(token, cb) {
     cb();
     return;
     }*/

    //let Dev specify sequlize config

    var sequelize = null;

    if ( self.settings.sequelize == null ) {
        var cfg = {}
        cfg.db = {}
        cfg.db.database = 'fileserver';
        cfg.db.user = 'root';
        cfg.db.password = 'password';
        cfg.db.port = '3306';

        //cfg.db.database

        var sequelize = new Sequelize(cfg.db.database, cfg.db.user, cfg.db.password, {
            dialect: "mysql", // or 'sqlite', 'postgres', 'mariadb'
            port: cfg.db.port, // or 5432 (for postgres)
            define: {
                timestamps: true//,
            }
        })
    }
    else {
        sequelize = self.settings.sequelize
    }



    t.test.connectToDb = function connectToDb(token, cb) {
        token.sequelize = sequelize
        sequelize
            .authenticate()
            .then(function(err) {
                if (!!err) {
                    console.log('Unable to connect to the database:', err, err.stack)
                } else {
                    console.log('Syced successfully.')
                    cb();
                }
            })

    }
    t.add(t.test.connectToDb)
    t.test.syncDatabaseDefintion = function syncDatabaseDefintion(token, cb) {


        var DataTypes = Sequelize;
        sh.each(self.settings.tables, function sync(k,v){
            v = v(sequelize, DataTypes)
            //v.sync();
        })


        sequelize.sync({force: self.settings.force}).then(function (err) {
            /* if (!!err) {
             console.log('Unable to sync the database:', err, err.stack)
             } else {*/
            console.log('Connection has been established successfully.')
            cb();

            /* }*/
        });
        return;


    }
    t.add(t.test.syncDatabaseDefintion);
}


SequelizeHelper.defineTable = function defineTable(tableSettings, cb) {
    var tableFields  = {}
    var tableOptions = {}
    tableOptions.timestamps=true;


    var sequelize = tableSettings.sequelize;
    var DataTypes = Sequelize;
    tableFields=  {
        id:{ type: DataTypes.INTEGER(10),
            allowNull: false,
            primaryKey:true,
            autoIncrement:true}
    }

    sh.each( tableSettings.createFields, function addField(k,v ) {

        //blank
        if ( v == null || v == "" ) {
            tableFields[k] = {
                type: DataTypes.STRING
                // allowNull: false,
            }
            return;
        }
        if ( v == true ) {
            tableFields[k] = {
                type: DataTypes.BOOLEAN
            }
            return;
        }

        if ( v instanceof Date ) {
            tableFields[k] = {
                type: DataTypes.DATE,
                allowNull: false,
                // defaultValue: 'CURRENT_TIMESTAMP'
            }
            return;
        }

        if (v.hasOwnProperty('_typeName')) {
            tableFields[k] = v
        } else {
            if (v.type == 0 || v == 0  ) {
                v.type = DataTypes.INTEGER(10);
            }
            if ( v.type == true  ) {
                v.type = DataTypes.BOOLEAN
            }
            tableFields[k] = v
        }
    })
    /*

     name: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     fileName: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     path: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     category: {
     type: DataTypes.STRING,
     allowNull: true,
     },
     type: {
     type: DataTypes.STRING,
     allowNull: false,
     },
     */
    /*updatedDate: {
     type: DataTypes.DATE,
     allowNull: false,
     defaultValue: 'CURRENT_TIMESTAMP'
     },*//*

     isDeleted: {
     type: DataTypes.BOOLEAN,
     allowNull: true,
     defaultValue: '0'
     }
     */

    var Table =  null;
    function newTableDefinition (sequelize, DataTypes) {
        return sequelize.define(tableSettings.name, tableFields, tableOptions)
    };

    Table = newTableDefinition(sequelize,Sequelize);

    if ( tableSettings.sync != false ) {
        sequelize.sync({force: tableSettings.force}).then(function (err) {
            /* if (!!err) {
             console.log('Unable to sync the database:', err, err.stack)
             } else {*/
            console.log('Connection has been established successfully.')
            //  cb();
            cb(Table);
            /* }*/
        });
    }

    else {
        cb(Table);
    }

    //self.Table = Table;

    return;
}


exports.SequelizeHelper = SequelizeHelper;
exports.SequelizeHelper.Sequelize = Sequelize;
if ( module.parent  == null ) {
    //return;
    var s = new SequelizeHelper()
    SequelizeHelper.updateDatabase();

}
