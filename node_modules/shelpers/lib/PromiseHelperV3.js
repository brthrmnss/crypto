/**
 *
 *Wrapper on promise library for ease of use
 * @type {{}}
 */

var isNode = true

if (typeof exports === 'undefined' || exports.isNode == false) {
    isNode = false
}

if ( isNode ) {
    var sh = require('shelpers').shelpers
}
//var Q = require("q");

function PromiseHelperV3() {
    var self = this;
    var p = PromiseHelperV3.prototype;

    self.starter = "--\t\t"
    self.debugName = self.starter + 'PromH'
    self.data = {}

    self.start = function start(arg1) {
        //var deferred = Q.defer();

        if (self.token.silentToken != true ) {
            console.log('starting...');
            console.log('starting/', arg1);
        }

        //deferred.resolve(arg1);
        //deferred.promise.fail(function (error) {
        //setTimeout( function wait500MsForLogToFlush() {
        ///    self.proc("error occured: " + error, JSON.stringify(error))//, error.stack);
        // }, 500)
        //console.error("error occured: " + error);
        // })
        ///self.lastPromise = deferred.promise
        //return deferred.promise;
        setTimeout(self.startNextMethod, 10);
    }

    function defineTransportControlMethods() {
        self.startNextMethod = function startNextMethodInChain() {
            if ( self.isPlaying == false ) {
                var e = new Error()
                console.error(e.stack)
                self.proc('double end call...', 'try sh.showLine')
                console.error('last time', self.data.closeStack )
                console.error('last time2',  self.data.lastStackPrex.stack)
                console.error(self.settings)
                setTimeout(function clearStOut() {
                    sh.x('bad')
                },20)

                return;
            }
            self.currentOperation = self.methods.shift();


            if (self.currentOperation == null) {
                if (self.methods.length == 0) {
                    self.data.logFxs.push('complete....')
                    if (self.token.name != null) {
                        self.proc('***Chain Complete', self.token.name);
                    } else {
                        console.log('done'); //, self.token.name);
                    }

                    if ( self.token.fxDone != null ) {
                        self.token.fxDone(self.token, self);
                    }

                    self.isPlaying = false;

                    self.data.closeStack = new Error().stack;
                    return;

                }
                setTimeout(self.startNextMethod, 10);
                return
            }


            var meth = self.currentOperation.fx;
            if ( self.currentOperation.fx == null ) {
                meth = self.currentOperation;
            }
            self.data.logFxs.push(meth.name)

            self.currentMethod = meth;
            var verifyHelper = {};
            self.data.lastCB2 = self.data.lastCB;
            self.data.lastCB = new Error()
            //method is callled after chain is complete
            self.currentCallback = function currentCallback_onDoneMethod(token) {
                var o = sh.log.showMethod(3)
                if ( self.isPlaying == false ) {
                    console.error('alreayd playing', token)
                    if ( token )
                    console.error('alreayd playing', token.y)
                    debugger;
                }
                //var e = new Error()
                //console.log('---', e.stack)
                //console.log('-',o)
               // sh.x()
                self.data.logFxs.push(['         ',o, self.data.timer.timeElapsed(4), sh.paren(meth.name) ].join(' '))
                if ( verifyHelper.called1X ) {

                    //
                    console.error('ok')
                    console.error( sh.toJSONString( self.data.logFxs) )
                    console.error(sh.n)
                    console.error('222')
                    console.error(self.data.lastCB2.stack)
                    console.error('111')
                    console.error(self.data.lastCB.stack)
                    console.error(sh.n)

                    console.error('double called request', new Error().stack )
                    console.error('double entry called', self.data.lastStackPrex.stack)
                    console.error('last tiem',   verifyHelper.calledFrom.stack)


                    if ( global.err )
                    console.error('ok c', global.err.stack)
                    throw(new Error('double call'))
                    sh.x()
                } else {
                    verifyHelper.called1X = true
                    verifyHelper.calledFrom = new Error();
                    verifyHelper.calledFrom = self.data.lastStackPrex;

                }

                //self.showProgress();
             
                //if ( fixDouble end call
                //sh.showLine('end callback')
                self.startNextMethod()
                return;
                setTimeout(self.startNextMethod, 10);
            }


            var fxLinkFinishedCB = self.currentCallback;

            //REQ: support timeout delays
            /*
             var stillActive = false;
             setTimeout(function warnIfTooLong() {
             if ( stillActive== true) {
             console.warn('this method goes on for long time', self.currentOperation.fx.name)
             }
             },10*1000 );
             fxLinkFinishedCB = function endChain() {
             stillActive = false;
             sh.fxForward(self.currentCallback,arguments );
             }
             */

            self.cb =
            self.next =
            self.nextLink = fxLinkFinishedCB
            //console.error('}}}}', self.token.name, meth.name)


            function runNextLink() {
                meth(self.token, fxLinkFinishedCB);
            }

            if ( self.token.delayLink) {
                setTimeout(runNextLink, self.token.delayLink)
            }else{
                runNextLink()
            }

        }


        /**
         * Retry the previous  method. (used when components are not ready)
         * @param delayTime
         */
        self.tryLater = function tryLater(delayTime) {
            self.methods.unshift(this.currentMethod);
            delayTime = sh.dv(delayTime, 500)
            setTimeout(self.startNextMethod, delayTime);
        }

        /**
         * simplify chaining
         * @param arg1
         * @returns {PromiseHelperV2}
         */
        self.startChain = function startChain(token, userSettings) {
            self.processSettings(userSettings)
            self.token = token;
            self.start(token);
            self.methods = []
            self.isPlaying = true;
            return self;
        }

        /**
         * Stop running this chain
         */
        self.stop = function stop() {
            self.methods = [];
            self.isPlaying = false;
            self.token = null; //overkill
        }

    }
    defineTransportControlMethods();


    /**
     * Mix in user settings.
     * @param userSettings
     * @returns {{}|*}
     */
    self.processSettings = function processSettings(userSettings) {

        self.defaultSettings = {}
        self.defaultSettings.addFailHandlerOnEnd = true
        self.defaultSettings.ignoreNull = true

        self.settings = self.defaultSettings;

        self.data = {}
        self.data.methods = {}
        self.data.methods.count = 0
        self.data.methods.currentIndex = 0
        self.data.logFxs = [];
        self.data.timer = sh.timer();

        return self.settings;
    }

    /**
     * Add method to work-chain
     * Method will be based 2 parameters,
     * token, and a callback
     * you must call the callback for the chain to proceed
     * @param fx
     * @returns {PromiseHelper}
     */
    self.add = function addNewFxToWorkChain(fx) {
        sh.throwIfNull(fx, 'Add valid step/link callback' )

        self.data.methods.count++
        self.methods.push({fx:fx, stack:sh.errors.storeError(6)})

        //self.lastAddition
        //self.lastPromise = self.lastPromise.then(self.w(fx))
        return self;
    }

    /**
     * Add method to work-chain at current step
     * Method will be based 2 parameters,
     * token, and a callback
     * you must call the callback for the chain to proceed
     * @param fx
     * @returns {PromiseHelper}
     */
    self.addNext = function addNext_NewFxToWorkChain(fx, offset) {
        self.data.methods.count++

        var method = {fx:fx, stack:sh.errors.storeError(6)}

        offset = sh.dv(offset,0);
        //self.data.offsetForAddNext++;
        //Remember: we remove method, so to add it next,
        //it goes to front of methods array
        self.methods.splice(offset, 0, method)

        return self;
    }

    //short for add Skip, stub does nothing
    self.addSkip = function addSkip(fx) {
    }
    self.addS = self.addSkip;

    self.sub = {}
    //alias to indicate substesps
    self.sub.add = self.add;

    /**
     * Add unwrapped method.
     * This is syncrhonous, no callback is passed
     * @param fx
     * @returns {PromiseHelper}
     */
    self.addSync = function addSync(fx) {
        self.data.methods.count++
        self.add(
            function rawWrapper (token, callback) {
                fx()
                callback(token)
            }
        )

        return self;
    }

    self.addRaw = self.addSync

    /**
     * Method indicates dev has completed adding methods to chain
     * @param fx
     * @returns {PromiseHelper}
     */
    self.end = function end(fx) {
        if ( self.settings.addFailHandlerOnEnd ) {
            self.failH =  function (error) {
                self.proc("error occurred: " + error);
                console.error("error occurred: " + error);
                console.error("error occurred: " + error.stack);
            } ;
        }

        self.addRaw(function () {
            console.log('finished.................', self.token.name, self.data.methods.count)
        });
        self.proc('added ', self.data.methods.count)
        return self;
    }

    self.showProgress = function showProgress() {
        var percentage  =  (self.data.methods.currentIndex/self.data.methods.count)
        percentage *= 100
        percentage = percentage.toFixed(2)
        percentage += '%'
        console.log(self.debugName, percentage)
        return
        self.proc('%',
            (percentage).toFixed(2), '%', self.data.methods.currentIndex, self.data.methods.count)
        return self;
    }



//    self.rawWrapper = function rawWrapper (token, callback) {
//        callback()
//    }

    self.fail = function fail(fx) {
        self.lastPromise = self.lastPromise.fail(fx)
        return self;
    }

    self.log = function log(arg1) {
        var deferred = Q.defer();
        //action(arg1, arg2, deferred.resolve);
        console.log('done...')
        console.log('log/', arg1)
        deferred.resolve(arg1);
        return deferred.promise;
    }

    self.log = function log(arg1) {
        self.add(function showToken(token, cb) {
            self.proc('log2', sh.toJSONString( self.token) )
            cb();
        })
        return self;
    }

    self.showToken = self.log

//    self.wrapMethod = function wrapMethod(fx) {
//        var wrapperFx = function autoGenWrapper(opts) {
//            var deferred = Q.defer();
//            fx(opts, deferred.resolve);
//            return deferred.promise;
//        }
//        return wrapperFx;
//    }

    self.wrapMethod = function wrapMethod(fx) {
        //this is for prototyping, devs may apply method placeholder
        //that do not exist
        if ( fx == null && self.defaultSettings.ignoreNull == true ) {
            return self.lastPromise;
        }
        var wrapperFx = function autoGenWrapper(token) {
            var deferred = Q.defer();
            function temp(token, resolve) {
                //console.log('-->', fx) //auto trace name
                //console.log('----------->')
                console.log()
                self.showProgress()
                self.data.methods.currentIndex++
                console.log(self.debugName, 'next method', fx.name)
                console.log()

                if ( token == null ) {
                    //we used to show warnings
                    //we have added token to self so if
                    //user forgets to pass it to callback,
                    // we will fix it ...
                    if ( self.settings.showNullTokenWarnings ) {
                        self.proc('token is null')
                    }
                    token = self.token;
                }
                fx(token, deferred.resolve);
            }
            function fxDone() {
                deferred.resolve(token) //auto commit token, and log
            }
            temp(token, fxDone);
            return deferred.promise;
        }
        return wrapperFx;
    }

    self.w = self.wrapMethod;

    //predefined helper methods to simpslify chain config
    self.utils = {}

    function utilsMethods() {
        self.utils.wait10Secs = function wait10Secs(token, callback) {
            if (self.wait == false) {
                callback(token)
                return
            }

            setTimeout(function wait10() {
                callback(token)
            }, 10 * 1000)

            var count = 10;
            var totalTime = 10000
            for (var i = 0; i < count; i++) {
                var time = i * 1000
                setTimeout(function tellTime(time) {
                    console.log((totalTime - time) + '...')
                }, time, time)
            }

        }

        self.utils.wait3Secs = function wait3Secs(token, callback) {
            setTimeout(function wait3() {
                callback(token)
            }, 3 * 1000)
        }

        self.utils.wait = function wait(duration, addToChain) {
            var hFx = {};
            hFx.error = new Error();
            if (duration == null ) {
                duration = 3;
            }
            var fxDelay = function instantWaitDefault(token, cb){
                setTimeout(function wait3() {
                    var y = hFx
                    y.self = self
                    var arg = y.self.cb == cb
                    //console.error(hFx.error.stack)
                    //cb(token)
                     self.cb(token)
                }, duration * 1000)
            }
            if ( addToChain != false ) {
                self.add(fxDelay);
            } else {
                return fxDelay;
            }

        }
    }
    utilsMethods();


    self.demo  = {}
    self.demo.exampleUsage = function exampleUsage() {
        log(data)
            /*
             .then(pb.searchForTorrent)
             .then(log)
             .then(pb.getFirstQueryResult)
             .then(log)
             .then(pb.convertMagnetLinkToTorrent)
             .then(log)
             */
            //cleanup existing files beforehand(or after)
            .then(wrapMethod(pb.putIORemoveFiles))
            .then(log)
    }



    self.demo.exampleInnerFx = function exampleInnerFx(opts, callback) {
        callback(opts)
    }


    p.proc = function proc() {
        sh.sLog(arguments)
    }


}



function runTest() {
    var self = {}
    self.searchByName = function search(token, cb) {
        console.log('searchByName')
        //asdf.g
        cb();
    }


    self.returnMagnetLink = function returnMagnetLink(token, cb) {

        setTimeout(function () {
            console.log('returnMagnetLink')
            cb()
        }, 200)
        ;
    }
    var token = {}
    var work = new PromiseHelperV3();
    token.silentToken = true
    work.wait = token.simulate == false;
    work.startChain(token)
        .add(self.searchByName)
        .log()
        //.add(self.getFirstQuery)
        //.add(self.convertMagnetLinkToTorrent)
        .log()
        .add(self.returnMagnetLink)
        .end();

}



//exports.PromiseHelperV2 = PromiseHelperV2;
exports.PromiseHelperV3 = PromiseHelperV3;
if ( isNode ) {
    if (module.parent == null) {


        runTest();

    }
} else {
    runTest();
}

