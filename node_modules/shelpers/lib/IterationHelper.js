/**
 *
 *Wrapper on promise library for ease of use
 * @type {{}}
 */

var sh = require('../../proxy/helpers/shelpers').shelpers
var Q = require("q");

/**
 * Script has background code for making service calls
 * Scripts like getGuid and getUserAccess can call ServiceCallHelper makeRequest to
 * abstract minute detils of hitting endpoints
 */

var Env = require('./serviceCallHelper').Env;
var XMLResponseHelpers = require('./../helpers/xml_response');
XMLResponseHelpers = XMLResponseHelpers.XMLResponseHelpers
var xmlHelpers = new XMLResponseHelpers();
var fakeFindUserResponse = require('./fakeResponses').fakeFindUsersByLoginName_niceguyn_n;
var fakePortalResponse = require('./fakeResponses').fakePortalResponse_niceguyn_n;
var xml2js = require('xml2js')
var jsonxml = require('jsontoxml');
var processors = xml2js.processors
var shelpers = require('./../helpers/shelpers').shelpers;
var OptionsHelper = require('./../helpers/optionsHelper').OptionsHelper;
var sh = shelpers
var async = require('async')

var AnalyzePortalCall = require('./../serviceCalls/analyzePortal').AnalyzePortalCall
var entitlementService = require('./../serviceCalls/entitlementService')


var getGuid = require('./getGuid').getGuid;
var getPortal = require('./getPortal').getPortal;
var entitlementService = require('./../serviceCalls/entitlementService')
var PromiseHelper = require('./PromiseHelper').PromiseHelper;
var AnalyzeGetUserAccess = require('./analyzeGetUserAccess').AnalyzeGetUserAccess



function IterationHelper() {

    var self = this;
    var p = IterationHelper.prototype;
    p = this;

    self.optionsHelper = new OptionsHelper();

    /**
     * Copy over
     * @param token
     * @param callback
     */
    p.iterateOver = function iterateOver(options) {

        self.optionsHelper.loadOptions( options )
        self.callback           =   self.optionsHelper.addOption('callback', 'completion callback', false)
        self.items        =   self.optionsHelper.addOption('items', 'items to iterator over')
        self.token                =   self.optionsHelper.addOption('token', 'to pass in', true)
        self.requiredFields        =   self.optionsHelper.addOption('file_output', 'completion callback', false)
        self.iterationCallback        =   self.optionsHelper.addOption('iterationCallback',
            ' callback for each item', true)
        self.autoCollect        =   self.optionsHelper.addOption('autoCollect',
            ' callback for each item', false, {})
        self.autoCollectIdFx //make id for dictionary collection
        //items, token, callback
        self.fxIdentifyItemCallback        =   self.optionsHelper.addOption('identifyItemCallback',
            ' callback to get an id of str name of item. used for indexing and logging', false, {})

        var token = self.token;
        //prob will want to split too
        //var componentsIds = sh.splitStrIntoArray(componentIds)

        //self.token.componentDictionary = {}
        async.forEachSeries(self.items, function (item, callback) {
            console.log('...iteration loop', item)
            var fxDone = function (name) {
                //self.proc('got', componentId, name)
                // if ( self.autoCollect != null) { //TODO: Add later
                //    autoCollect[]
                //self.token.componentDictionary[componentId] = name;
                //  }
                callback();
            }
            /*
             var miniToken = {}
             miniToken.componentId=componentId
             miniToken.env = token.env
             miniToken.callback = fxDone
             miniToken.fakeResponse = self.simulate(entitlementService.sampleGetComponentResult)
             entitlementService.getComponent(miniToken);*/
            self.iterationCallback(item, fxDone, self.token) //token workspace
        }, function (err) {
            if (err) {
                console.log(err)
            }
            //self.proc(sh.toJSON(self.token.componentDictionary))
            self.callback()
        });
    }

}


function TestEntitlement() {

    var self = this;
    var p = TestEntitlement.prototype;
    p = this;

    self.optionsHelper = new OptionsHelper();

    /**
     * Prefered way to kick off these helpers.
     * SEnd object, send, null if you don't know the parameters
     * @param username
     * @param env
     * @param callback
     * @param resp
     * @param d
     * @param file
     * @param surpressErrors
     * @returns {*}
     *
     * //TODO: why copy when you can store on option?
     */
    p.test = function test(options) {
        self.optionsHelper.loadOptions( options )
        self.callback           =   self.optionsHelper.addOption('callback', 'completion callback', false)
        self.reqUsername        =   self.optionsHelper.addOption('username', 'username to analyize', true)
        self.username           =   self.reqUsername
        self.env                =   self.optionsHelper.addOption('env', 'Env source, or teambox url', true)
        self.file_output        =   self.optionsHelper.addOption('file_output', 'completion callback', false)
        self.surpressErrors     =   self.optionsHelper.addOption('surpressErrors', '', false)
        self.componentIds     =   self.optionsHelper.addOption('componentIds', '', false)




        self.guid = self.guid
        self.simulate = self.simulate

        self.silent =  self.optionsHelper.addOption('silent', '', false, false) //required if username not set

        if ( self.optionsHelper.sentNull() ){
            return self.optionsHelper.optionInstructions;
        }

        //if ( resp == null && self.fakePortalResponse != null ) {
        self.fakePortalResponse =  self.optionsHelper.addOption('fakePortalResponse',
            'fake response for getPortal call', false, null)
        //}

        self.options  = options;
        self.token = options;
        self.token.output ={}

        var work = new PromiseHelper();

        work.startChain(token)
            .add(self.getPortal)
            .add(self.getComponents)
            .add(self.startProxy)
            .add(self.testComponents)
            .add(self.getUserAccess)
            .addRaw(function finishedProcessingWork() {
                console.log('finished.................')
                var outputToken = sh.clone(self.token)
                //portal response is long ... abbreviate it
                outputToken.output.portal = sh.toJSON(outputToken.output.portal).length
                self.proc('output', sh.toJSONString(outputToken))
                sh.callIfDefined(self.token.callback)
            })
            .fail(function (error) { //TODO: make this default
                //console.log("error occured: " + error,error.stack )//, JSON.stringify(error))//, error.stack);
                setTimeout(function showOutput() {
                    console.log("error occured: " + error,error.stack);
                    console.error("error occured: " + error,error.stack);
                }, 500)
            })
        //self.getPortal();
        //self.getComponents();
        //self.startProxy( self.testComponents);
        //self.getUserAccess();

        return;
    }

    p.getPortal = function getPortal(token, callback) {
        var analyzePortal = new AnalyzePortalCall();
        self.analyzePortal = analyzePortal
        analyzePortal.analyzePortalObj(self.token)
        analyzePortal.callback = function onProcessPortal(getUserClientsAppsResponseJSON) {
            self.token.output.portal = getUserClientsAppsResponseJSON;
            //self.token.guid  = getUserClientsAppsResponseJSON.user.Guid;
            self.token.guid  = analyzePortal.guid;
            self.token.caids  = analyzePortal.getCaids();
            callback();
        }
    }

    p.getComponents = function getComponents(token, callback) {
        var token = self.token;
        var componentIds = token.componentIds
        if ( componentIds == null ) {
            callback(token)
            return;
        }
        var componentsIds = sh.splitStrIntoArray(componentIds)

        self.token.componentDictionary = {}
        async.forEachSeries(componentIds, function (componentId, callback) {
            console.log('getComponentId', componentId)
            var fxDone = function (name) {
                self.proc('got', componentId, name)
                self.token.componentDictionary[componentId] = name;
                callback();
            }
            var miniToken = {}
            miniToken.componentId=componentId
            miniToken.env = token.env
            miniToken.callback = fxDone
            miniToken.fakeResponse = self.simulate(entitlementService.sampleGetComponentResult)
            entitlementService.getComponent(miniToken);
        }, function (err) {
            if (err) {
                console.log(err)
            }
            self.proc(sh.toJSON(self.token.componentDictionary))
            callback(token)
        });
    }



    p.startProxy = function getPortal(token, callback) {
        //ne pngproxy
        var analyzePortal = new AnalyzePortalCall();
        self.analyizePortal = analyzePortal
        self.token
        analyzePortal.analyzePortalObj(self.token)
        analyzePortal.callback = function onProcessPortal(json) {
            self.token.output.proxy = 'started'
            callback(token)
        }
    }

    p.testComponents = function testComponents(token, callback) {
//pstdr and splitjsonm
        //call into hjava
        //what was java invocation helper ? used by amfparse?
        //login into serve to get new phrase
        var analyzePortal = new AnalyzePortalCall();
        self.analyizePortal = analyzePortal
        self.token
        analyzePortal.analyzePortalObj(self.token)
        analyzePortal.callback = function onProcessPortal(json) {
            self.token.output.proxy = 'started'
            callback(token)
        }
    }

    /**
     p.getUserAccess = function getUserAccess(token, callback) {
        function parsedJson(json) {
            token.output.roleJson = json;
            //get shorted length
            //token.output.rolesAnalysis = rolesAnalysis
            callback()
            return
        }
        var rolesAnalysis = new AnalyzeGetUserAccess()
        var tokenInput = self.cloneToken()
        tokenInput.simulate = self.simulate() //if input null return true
        tokenInput.showJSONOutput = false;
        rolesAnalysis.processInputOptions(token)
        rolesAnalysis.callback = parsedJson
    }

     */

    p.getUserAccess = function getUserAccess(token, callback) {


        token.output.accessPerCaid={}
        function analyizeAccess(caid, oneCaidDoneCallback, token){
            function parsedJson(json) {
                //token.output.roleJson = json;
                token.output.accessPerCaid[caid] = json;
                //get shorted length
                //token.output.rolesAnalysis = rolesAnalysis
                oneCaidDoneCallback()
                return
            }
            var rolesAnalysis = new AnalyzeGetUserAccess()
            var tokenInput = self.cloneToken()
            tokenInput.simulate = self.simulate() //if input null return true
            tokenInput.showJSONOutput = false;
            tokenInput.caid=caid
            tokenInput.silent = true
            rolesAnalysis.callback = parsedJson
            rolesAnalysis.processInputOptions(tokenInput)



        }

        function finishedGettingCaids() {
            callback()
        }


        var options = {}
        options.items = self.token.caids
        options.callback = finishedGettingCaids
        options.token = self.token
        options.iterationCallback = analyizeAccess;
        var i  = new IterationHelper();
        i.iterateOver(options)
    }




    /**
     * Convience method to clone the token
     * @returns {*|Mixed|clone|clone|clone|clone}
     */
    p.cloneToken = function cloneToken(){
        return sh.clone(self.token)
    }

    /**
     * Should we simulate?
     * @returns {}
     */
    p.simulate = function simulate(fakeResposneData){
        if (token.simulate == true ){
            if ( fakeResposneData == null) {
                return true;
            }
            else {
                return fakeResposneData;
            }
        }
        else {
            if ( fakeResposneData == null) {
                return false;
            }
            else {
                return null;
            }
        }
    }

    p.proc = function proc() {
        sh.sLog(arguments)
    }
}
exports.Env = Env;
exports.TestEntitlement = TestEntitlement;








if (module.parent == null) {
    var args = process.argv.splice(2);
    var h = new TestEntitlement();
    if (args.length == 0) {
        //simulateCall()
        var token = {} ;
        token.simulate = true
        token.username = 'westwest'
        token.env = Env.N1;
        h.test(token)
    }
    else {
        h.analyzePortal(args[0], args[1], null, null, null, args[2], true)
        h.teamboxUrlPreamble = teamboxUrlPreable
    }
}

exports.PromiseHelper = PromiseHelper;

if ( module.parent == null ) {



}