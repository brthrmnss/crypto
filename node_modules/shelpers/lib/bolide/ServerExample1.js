/**
 * Created by smorris1 on 1/3/14.
 * Encapsulates all loigc for remote server
 */
var sh = require('shelpers').shelpers;
var Server = require('./BolideServer').BolideServer;
var Client = require('./BolideUIClient').BolideUIClient;

var TemplateCommands = require('./TemplateCommands')

var type = {}
type.tasks  = {}
type.tasks.fiveSecTask = 'fiveSecTask'

var PromiseHelper = require('shelpers').PromiseHelper;
var OptionsHelper = require('shelpers').OptionsHelper
var SettingsHelper = require('shelpers').SettingsHelper

function ServerExample1() {
    var p = ServerExample1.prototype;
    p = this;
    var self = this;
    var achievements = [];
    self.achievements = achievements;

    self.data = {}

    p.loadConfig = function loadConfig(configFile) {

        self.go(configFile)
        return

        var defaultSettings = {};
        defaultSettings.dirDownload = null
        defaultSettings.throwErrorWhenQueryNotFound = false;
        var sH = new SettingsHelper();
        self.settingsHelper = sH;
        sH.defaultSettings = defaultSettings;

        //self.data.configFile = configFile;
        sH.loadOptions(configFile, function doneLoadingSettingsFile ( settings ){
            self.proc('options', settings)
            self.settings = settings;
            self.go( settings)
        }, ['c:/configs/, c:/trash', 'c:/trash/configs'])
    }

    self.go = function go(options) {

        var paramsHelper = new OptionsHelper();
        paramsHelper.loadOptions(options)
        // var fxCallback = paramsHelper.addOption('callback', 'completion callback', true)
        // var query = paramsHelper.addOption('query',
        //    'what torrent to look for', true)

        var token = sh.clone(options)
        self.token = token
        //token.query=query
        // token.fxCallback=fxCallback;

        var work = new PromiseHelper();
        work.name = 'Template Chain'
        work.wait = token.simulate==false;
        work.startChain(token)
            .add(self.createActors)
            .add(self.createClient)
            .add(self.defineTasks)
            //   .add(self.testClientCmds)
            //   .add(self.testClientCmds2)
            //.add(self.testClientCmds3)
            //  .add(self.testClientCmds_JSONWrittenCommand)
            //.add(self.testClientCmds_JSONWrittenCommand_HARProxy)
            .add(self.testClientCmds_JSONLiveCommand_HARProxy)
            .add(self.testClientCmds_JSONLiveCommand_HARDownloader)
            /*
             .add(self.waitStart)
             .add(self.basicTest)
             //.addWaitFor(function(){return token.finished})
             // .add(self.basicTest2)
             .add(self.verifyDontSendCommands)
             .add(self.testCreatingTask)
             */
            .end();
    }

    function createComponents() {
        p.logic = {}
        /**
         * return urlMagnet
         * @param token
         * @param cb
         */
        p.logic.returnMagnetLink = function returnMagnetLink(token, cb) {
            self.proc(token.torrentName)
            cb()
            token.fxCallback(token.urlMagnet)

        }
    }
    createComponents();

    var c = null;
    var s = null;

    function defineWork() {
        p.createActors = function createActors(token, cb) {
            function createServer() {
                s = new Server();
                s.testMode = true
                self.s = s;
                var serverSettings = {}
                serverSettings.portProxy = token.port;;// 7789
                s.loadSettings(serverSettings)
                s.fxStarted = function onServerStarted() {
                    cb( )
                    //
                    ///open('http://localhost:7789/geetguid3.htm')
                }
            }
            createServer();

        }

        p.createClient = function createClient(token, cb) {
            c = new Client();
            self.c = c;
            var clientSettings = {}
            clientSettings.name = 'testServerClient'
            clientSettings.port = token.port
            c.loadSettings(clientSettings
            );
            //c.pullModel(function onGotModel(){
            cb()
            //})

        }

        p.defineTasks = function defineTasks(token, cb) {
            //create template system
            var cmds = [
                [NodeJSPropScript,'sc1', {file:"test/RequireScriptTest", obj:"RequireScriptTest"}],
                //for testing ... return data property
                [StubCommand,'sc2', {delay:0}],
                [NodeJSChildScript,'sc3', {file:"test/ChildProcessTestScript.js", writeConfig:false} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSChildScriptV2,'sc4', {file:"/../../../../proxy/swfProxy/EnvCheckerHelper.js"} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSChildScriptV2,'runHarProxy',
                    {file:"../../../../proxy/verifications/har_proxyserver.js"} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSInnerScript,'runHarProxy',
                    {file:"../../../../proxy/verifications/har_proxyserver.js",
                        obj:"HARProxyServer", noTryCatch:false} ],
                [TemplateCommands.OpenUrl,'openUrl', {url:'www.yahoo.com'}  ]
            ]

            function NodeJSPropScript() {
                var p = NodeJSPropScript.prototype;
                var p = this;
                var self = this;

                self.name = 'NodeJSPropScript'
                self.settings = {}

                p.execute = function execute() {
                    //    try {
                    var sdf = require('./'+self.properties.file)[self.properties.obj]
                    var instance = new sdf()
                    //assumes you send callback
                    self.data.fxCallback = function commandFinished(json) {
                        self.ok(json)
                    }
                    instance.loadConfig(self.data)
                    // } catch ( e ) {
                    //      self.fail(e, e.stack)
                    //  }
                    return;
                }
            }
            function NodeJSChildScript() {
                var p = NodeJSChildScript.prototype;
                var p = this;
                var self = this;

                self.name = 'NodeJSChildScript'
                self.settings = {}
                p.execute = function execute() {
                    var writeConfig = self.properties.writeConfig;
                    if ( writeConfig) {
                        //write temp file and pass to script as first arg
                    }

                    var CommandRunner = sh.CommandRunner
                    var cR  = new CommandRunner();
                    var settings ={}
                    settings.cmd = 'node'
                    var pathToScript = __dirname + '/'+self.properties.file;
                    settings.args = [pathToScript]
                    if ( self.data.args != null ) {
                        //user arguments
                        settings.args = settings.args.concat(self.data.args)
                    }
                    //mixin arguments
                    //self.properties

                    var fxCallbackTestComplete = function fxCallbackTestComplete() {
                        console.log('done')
                        // self.ok('ddddd')
                        self.ok(self.output)
                    }
                    self.output  = ''
                    settings.fxEcho =  function fxEcho(data){
                        self.output += data
                    }

                    settings.fxCallback = fxCallbackTestComplete
                    cR.execute(settings)

                }
            }

            /**
             * For testing, client sends up data with 'output'
             * property.
             * Server taxkes output and sends back that as result
             * @constructor
             */
            function StubCommand() {
                var p = StubCommand.prototype;
                var p = this;
                var self = this;

                self.name = 'StubCommand'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    var delay = sh.defaultValue(self.properties.delay,0)
                    setTimeout(function returnDataOutput () {
                        self.ok(self.data.output);
                    }, delay)

                    return;
                }
            }

            function VCommand2() {
                var p = VCommand2.prototype;
                var p = this;
                var self = this;

                self.name = 'some random command'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    setTimeout(function x () {
                        self.ok('555');
                        //only appliest during test...
                        try {
                            c.model = s.model;
                            c.updatedModel();
                        } catch ( e ) {}
                    }, 5000)

                    return;
                }
            }

            function VCommand2() {
                var p = VCommand2.prototype;
                var p = this;
                var self = this;

                self.name = 'some random command'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    setTimeout(function x () {
                        self.ok('555');
                        //only appliest during test...
                        try {
                            c.model = s.model;
                            c.updatedModel();
                        } catch ( e ) {}
                    }, 5000)

                    return;
                }
            }
            self.VCommand2 = VCommand2;
            self.s.tasks.addTaskType('testTask3', VCommand2)
            self.s.tasks.addTaskType(type.tasks.fiveSecTask, VCommand2)

            sh.each(cmds, function registerCmd(i, cmdSettings){
                var cmdClazz = cmdSettings[0];
                var cmdName = cmdSettings[1];
                var cmdProperties = cmdSettings[2];
                self.s.tasks.addTaskType(cmdName, cmdClazz, cmdProperties)
            })

            cb()
        }

        p.pullModel = function pullModel(token, cb) {
            cb( )
        }

        p.waitStart = function waitStart(token, cb) {

            token.i = setInterval(function tryAGain() {
                if (self.s.started ) {
                    clearInterval(token.i)
                    cb()
                    return;
                }
            },500)

        }


        p.testClientCmds = function testClientCmds(token, cb) {

            c.tasks.addTask('sc2',
                {output:5},
                function fiveSecTaskDone( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }



        p.testClientCmds2 = function testClientCmds2(token, cb) {

            c.tasks.addTask('sc1',
                {output:5},
                function fiveSecTaskDone( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }
        p.testClientCmds3 = function testClientCmds3(token, cb) {

            c.tasks.addTask('sc3',
                {output:5, args:[6666]},
                function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }

        p.testClientCmds_JSONWrittenCommand = function testClientCmds_JSONWrittenCommand(token, cb) {

            c.tasks.addTask('sc4',
                {output:5, input:{env:"n", testUsernames:"nvisioncpa1"}},
                function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }
        p.testClientCmds_JSONWrittenCommand_HARProxy = function testClientCmds_JSONWrittenCommand(token, cb) {


            /*  c.tasks.addTask('runHarProxy',
             {output:5, input:{env:"n", harFile:"eam.N.har"}},
             function onCompletedForkedNodeScriptTask( xc, success, result){
             console.log('callback 5 sec task done');
             self.achievements.push('ran and tested a remote task');
             cb();
             c.syncStop();
             }
             )*/

            var taskSettings = {} ;
            taskSettings.taskType = 'runHarProxy'
            taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
            taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
            taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                console.log('callback 5 sec task done');
                self.achievements.push('ran and tested a remote task');
                cb();
                c.syncStop();
            }

            taskSettings.fxUpdate = function onUpdate(x){
                console.log('client', 'got update', x)
            }
            var newTask = c.tasks.createTask(taskSettings);



            sh.wait1Sec(function updateTask(){
                newTask.addUpdate({m:'he'})
            }, 'add update to task to send to remote end')
            sh.waitXSecs(3,function updateTask(){
                newTask.addUpdate({m:'he222'})
                newTask.addUpdate({type:"method",m:'he222'})
            }, 'add update to task to send to remote end 3')

            sh.waitXSecs(4,function updateTask2(){
                newTask.addUpdate({m:'he222'})
                newTask.addUpdate({type:"method",
                    methodName:'testMeth', args:[5,6]})
            }, 'add update to task to send to remote end 3')

            c.syncContinually(1)

        }

        p.testClientCmds_JSONLiveCommand_HARProxy = function testClientCmds_JSONLiveCommand_HARProxy(token, cb) {


            /*  c.tasks.addTask('runHarProxy',
             {output:5, input:{env:"n", harFile:"eam.N.har"}},
             function onCompletedForkedNodeScriptTask( xc, success, result){
             console.log('callback 5 sec task done');
             self.achievements.push('ran and tested a remote task');
             cb();
             c.syncStop();
             }
             )*/

            function runHARTask(){
                var taskSettings = {} ;
                taskSettings.taskType = 'runHarProxy'
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har", exitProcess:false}}
                taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done');
                    self.achievements.push('ran and tested a remote task');
                    cb();
                    //c.syncStop();
                }

                taskSettings.fxUpdate = function onUpdate(x){
                    console.log('client', 'got update', x)
                    if (self.data.runHARTaskMessages==null) {
                        self.data.runHARTaskMessages = []
                    }
                    if ( sh.isString(x) == false ) {
                        x=JSON.stringify(x) //w: for later comparison
                    }
                    self.data.runHARTaskMessages.push(x)
                }

                var newTask = c.tasks.createTask(taskSettings);
                return newTask
            }


            var newTask =  runHARTask()


            //todo ... verify functioning.... that remove is recieving requests
            function sendUpdates() {

                function hasMessage(message, throwError) {
                    message = JSON.stringify(message);
                    if ( sh.includes(self.data.runHARTaskMessages,message)){
                        return true
                    }
                    if ( throwError != false ) {
                        throw new Error('did not receieve a message '+message)
                    }
                    return false;
                }

                sh.waitXSecs(3,function updateTask(){
                    var checkMsg = newTask.addUpdate({m:'he', type:"echo"})
                    sh.waitXSecs(10,function updateTask(){
                        hasMessage(checkMsg)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end')



                //verify messages are being sent
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    var checkMsg = newTask.addUpdate({type:"method",m:'he222', type:"echo"})

                    sh.waitXSecs(5,function updateTask(){
                        hasMessage(667, false)
                        hasMessage(checkMsg, false)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTaskCallMethodToEcho(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:['testMethoEcho']})
                    sh.waitXSecs(5,function verifyMessageReiceved(){
                        hasMessage(["testMethoEcho"])
                        ///>>>
                        restartTask()

                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            sendUpdates()



            function restartTask() {

                sh.waitXSecs(4,function restartHarTask(){
                    var task = self.s.tasks.utils.getTask('runHarProxy')
                    var task_id = task.id;
                    self.data.taskIDOrigHAR = task_id
                    self.proc('restarting server ...')
                    //w:old server will close, providing a lapse with no calllbacks
                    sh.waitXSecs(15,function provideLapseTimeForServerToCatchUp(){
                        self.proc('lapse over')
                        var task = self.s.tasks.utils.getTask({name:'runHarProxy',completed:false}, true)
                        var task_id = task.id;
                        if ( task_id == self.data.taskIDOrigHAR ) {
                            throw new Error('Tasks did not change')
                        }
                    } )

                    try {
                        runHARTask()
                    } catch (  e) {
                        self.proc('error', e)
                    }
                }, 'restart the har task')

                sh.waitXSecs(50,function verifyIdIsChanged(){
                    // self.s.tasks
                }, 'restart the har task...')
            }

            //restartTask()




            function startDownloadTask() {
                sh.wait1Sec(function updateTask(){
                    newTask.addUpdate({m:'he'})
                }, 'add update to task to send to remote end')
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",m:'he222'})
                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTask2(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            //  startDownloadTask()


            cb();
        }

        p.testClientCmds_JSONLiveCommand_HARDownloader = function testClientCmds_JSONLiveCommand_HARDownloader(token, cb) {

            var Task = {}
            Task.HARDownloader = 'harDownloader'
            self.s.tasks.addTaskType('harDownloader', TemplateCommands.NodeJSInnerScript,
                {file:"../../../../proxy/verifications/HARReader.js",
                obj:"HARReader", noTryCatch:false})

            function runHARDownloaderTask(){
                var taskSettings = {} ;
                taskSettings.taskType = Task.HARDownloader
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har", exitProcess:false}}
                taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done');
                    self.achievements.push('ran and tested a remote task');
                    cb();
                    //c.syncStop();
                }

                taskSettings.fxUpdate = function onUpdate(x){
                    console.log('client', 'got update', x)
                    if (self.data.runHARTaskMessages==null) {
                        self.data.runHARTaskMessages = []
                    }
                    if ( sh.isString(x) == false ) {
                        x=JSON.stringify(x) //w: for later comparison
                    }
                    self.data.runHARTaskMessages.push(x)
                }

                var newTask = c.tasks.createTask(taskSettings);
                return newTask
            }


            var newTask =  runHARDownloaderTask()


            return;

            //todo ... verify functioning.... that remove is recieving requests
            function sendUpdates() {

                function hasMessage(message, throwError) {
                    message = JSON.stringify(message);
                    if ( sh.includes(self.data.runHARTaskMessages,message)){
                        return true
                    }
                    if ( throwError != false ) {
                        throw new Error('did not receieve a message '+message)
                    }
                    return false;
                }

                sh.waitXSecs(3,function updateTask(){
                    var checkMsg = newTask.addUpdate({m:'he', type:"echo"})
                    sh.waitXSecs(10,function updateTask(){
                        hasMessage(checkMsg)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end')



                //verify messages are being sent
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    var checkMsg = newTask.addUpdate({type:"method",m:'he222', type:"echo"})

                    sh.waitXSecs(5,function updateTask(){
                        hasMessage(667, false)
                        hasMessage(checkMsg, false)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTaskCallMethodToEcho(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:['testMethoEcho']})
                    sh.waitXSecs(5,function verifyMessageReiceved(){
                        hasMessage(["testMethoEcho"])
                        ///>>>
                        restartTask()

                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            sendUpdates()



            function restartTask() {

                sh.waitXSecs(4,function restartHarTask(){
                    var task = self.s.tasks.utils.getTask('runHarProxy')
                    var task_id = task.id;
                    self.data.taskIDOrigHAR = task_id
                    self.proc('restarting server ...')
                    //w:old server will close, providing a lapse with no calllbacks
                    sh.waitXSecs(15,function provideLapseTimeForServerToCatchUp(){
                        self.proc('lapse over')
                        var task = self.s.tasks.utils.getTask({name:'runHarProxy',completed:false}, true)
                        var task_id = task.id;
                        if ( task_id == self.data.taskIDOrigHAR ) {
                            throw new Error('Tasks did not change')
                        }
                    } )

                    try {
                        runHARTask()
                    } catch (  e) {
                        self.proc('error', e)
                    }
                }, 'restart the har task')

                sh.waitXSecs(50,function verifyIdIsChanged(){
                    // self.s.tasks
                }, 'restart the har task...')
            }

            //restartTask()




            function startDownloadTask() {
                sh.wait1Sec(function updateTask(){
                    newTask.addUpdate({m:'he'})
                }, 'add update to task to send to remote end')
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",m:'he222'})
                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTask2(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            //  startDownloadTask()


        }


        p.basicTest = function basicTest(token, cb) {
            token.finished = false
            c.syncModel(step2);


            function step2(model) {
                c.model.hi = 'dddddd'
                c.model.emptyT = [5]
                c.syncModel(step3, true);
            }
            //step2();

            function step3(model) {
                c.model.hi = 'hhhhhhh'
                c.syncModel(step4, true);
            }

            function step4(model) {
                console.log('model', c.model)
                cb()
                token.finished = true
            }


        }
        p.verifyDontSendCommands = function verifyDontSendCommands(token, cb) {

            var UIOnlyTask = 'UIOnlyTask'


            var bail = false
            self.c.tasks.addTaskType(UIOnlyTask, self.VCommand2)
            var task = c.tasks.addTask(UIOnlyTask,
                '...desc',
                function fiveSecTaskDone(){
                    self.proc('UIOnlyTask', 'callback 5 sec task done')
                    if ( bail == true ){
                        return
                    }
                    cb()
                }
                , 'desc', self.c.settings.name)
            var result = c.syncModel(step2);
            if ( result != null ){
                // bail = true
                throw 'sent the file up....'
            }
            function step2(model) {
                //c.model.hi = 'dddddd'
                //  c.model.emptyT = [5]
                // c.syncModel(step3, true);
            }


        }
        var testerData = {}
        p.testCreatingTask = function testCreatingTask(token, cb) {

            function testCreatingTask(){
                var task = c.tasks.addTask(type.tasks.fiveSecTask,
                    'testCreatingTask',
                    function fiveSecTaskDone(){
                        console.log('callback 5 sec task done')
                        self.achievements.push('ran and tested a remote task')
                        cb()
                    }
                )
                testerData.fiveSecTaskId  =    task.id
                setTimeout(verifyTestCreatingTask, 5000)
                c.tasks.hasTask(testerData.fiveSecTaskId);
                //c.syncModel(verifyTestCreatingTask, true);
                c.syncContinually(1, verifyTestCreatingTask)
            }

            testCreatingTask();


            function verifyTestCreatingTask(model){
                return;
                if ( c.tasks.isTaskDone(testerData.fiveSecTaskId) ) {
                    console.log('task done....')
                } else {
                    console.log('task not done....')
                }
                c.model.hi = false
                //c.pullModel(step4, true);
            }
        }
    }
    defineWork()

    function defineUtils() {
        p.utils = {}
    }

    defineUtils();

    /**
     * Receive log commands in special format
     */
    p.proc = function proc() {
        sh.sLog(arguments)
    }
}

if (module.parent == null) {


    var t = new ServerExample1()
    var options = {}
    options.port = 7789
    t.loadConfig(options);
    return;

}



