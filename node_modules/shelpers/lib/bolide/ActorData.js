/**
 * Created by smorris1 on 1/3/14.
 * Encapsulates an  endpoint
 * tasks
 * name
 * exports actor's section of the model
 * import updates
 */

//console.log(this["sh"], sh)


var isBrowser = false
var isNode = true

if (typeof require !== 'undefined') {

    var sh = require('shelpers').shelpers;
    var SettingsHelper = require('shelpers').SettingsHelper;
    var express = require('express')
}
else {
    isBrowser = true
    isNode = false
}


function Actor() {
    var p = Actor.prototype;
    p = this;
    var self = this;

    self.data = {}
    self.data.model = {}

    self.model = {}
    self.tasks = {}
    self.incomingTasks = {};
    self.name = 'unamed actor'
    self.private = {} //data is never serialized
    self.revision_number = {}
    self.settings = {}


    p.processTasks = function processTasks(tasks) {
        return;
        //can user add tasks
        sh.each(tasks, function fiterTasks(i, task){

        })
    }

    p.addTask = function addTask(name, taskType) {
        var task = {}
        task.type = 'task'
        task.name = name;
        task.taskType = taskType;

        return task;
    }


    /**
     * Create a clear model to send to the other side
     * @returns {{}}
     */
    p.cleanModelForSend = function cleanModelForSend() {
        var tempModel = {}
        var skipProps = ['logChanges', 'remote',
            'actor', 'data', 'model']


        //feature: optimize ... simple copy only the properties you want
        if ( self.actor.model.actor!=null && self.actor.model.actor.length>0 ) {
            //sh.wait1Sec(function() {throw 'failed check'})
            //throw 'failed check'
        }
        sh.each(self.actor.model, function copyToModel(propName,x) {
            if ( sh.includes(skipProps, propName )  ) { return; }
            try {
                tempModel[propName] = sh.clone(x)
            } catch( e ){
                throw e
            }
        })

        return tempModel;
    }


    /**
     * Bad bug, where nulls are converted into empty string arrays
     * @returns {{}}
     */
    p.copyInRecievedModel = function copyInRecievedModel(newModel) {
        var tempModel = {}
        var skipProps = ['logChanges', 'remote',
            'actor', 'data', 'model']

        //feature: optimize ... simple copy only the properties you want
        if ( self.actor.model.actor!=null && self.actor.model.actor.length>0 ) {
            //sh.wait1Sec(function() {throw 'failed check'})
            //throw 'failed check'
        }
        sh.each(self.actor.model, function copyToModel(propName,x) {
            if ( sh.includes(skipProps, propName )  ) { return; }
            self.actor.model[propName]=x;
        })

    }



    function defineModelChecks(){
        p.checkSendableModel = function checkSendableModel(model,  throwError) {
            if ( model.data != null || model.actor != null ) {
                if ( throwError != false )
                    throw 'invalid sendn...'
            }
        }
        p.checkModel = function checkModel(model,  throwError) {
            if (  self.actor.model.data != null && self.actor.model.data.length > 2 ) {
                if ( throwError != false )
                    throw 'invalid checkModel'
            }
        }
    }
    defineModelChecks()




    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }

}


if ( sh.isNode ) {

    if (module.parent == null) {

    }


    exports.Actor = Actor;

}

Actor.PrivateData = ['private']