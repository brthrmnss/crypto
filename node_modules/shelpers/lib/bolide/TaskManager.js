/**
 * Created by smorris1 on 1/3/14.
 * Encapsulates
 * completed .. purged ,
 * log
 *
 */

var isBrowser = false
var isNode = true

if (typeof require !== 'undefined') {
    var sh = require('shelpers').shelpers;
    var SettingsHelper = require('shelpers').SettingsHelper;
    var express = require('express')
}
else {
    isBrowser = true
    isNode = false
}

function Task() {
    var p = Task.prototype;
    p = this;
    var self = this;

    self.name = 'unamed'
    self.source = null;
    self.processor = null;

    self.data = {}
    self.data.model = {}

    self.settings = {}

    var types = {}
    types.TIMEOUT = '%%%TIMEOUT%%%'

    p.processTasks = function processTasks(tasks) {
        return;
    }

    /**
     * Take json, populate task
     * @private
     */
    p._import =  function _import(x) {

    }

    p._export = function _export(r) {

    }
}



function GenericCommandExample() {
    var p = GenericCommandExample.prototype;
    p = this;
    var self = this;

    self.name = 'some random command'
    self.settings = {}

    p.execute = function execute() {
        //self.data
        //self.success();
        self.fail('broken');
        return;
    }
}

function TaskManager() {
    var p = TaskManager.prototype;
    p = this;
    var self = this;

    if ( TaskManager.id == null ) {
        TaskManager.id = 0
    }
    TaskManager.id++;

    self.utils = {}
    self.data = {}
    self.actor = {}
    self.settings = {}
    self.data.dictTaskToFx = {};
    //store settings on processing tasks
    self.data.dictTaskIdToSettings={};
    self.data.dictTaskTypes = {}
    self.data.dictTaskTypesSettings = {}
    self.data.finishedTasks = []
    self.name = function() {
        return self.settings.name;
    }

    function conv(x) {
        if ( x == "true" || x == true )
            return true;

        if ( x == 'false' || x == false )
            return false

        x = false
        return x
    }

    p.client = function client() {
        var client = self.actor.constructor.name ==  "BolideUIClient"
        return client;
    }


    //bookmark: process tasks
    /**
     * Remove aold tasks, verify tasks are legitimate
     */
    function filterTasks() {
        p.processTasks = function processTasks(tasks) {
            var filteredTasks = []
            var debugTaskProcessing = true
            debugTaskProcessing = false;
            //return;
            //can user add tasks
            if ( debugTaskProcessing ) {
                var starter = '\t\t\t'
                console.log('   ', self.name(), ':')
            }
            self.actor.actor.checkModel();
            sh.each(self.actor.model.tasks, function filterTasks(i, task) {
                var debug = {}
                debug.client = self.actor.constructor.name ==  "BolideUIClient"
                task.started = conv(task.started)
                task.completed = conv(task.completed)

                //if task is complete
                if ( debugTaskProcessing ) {
                    self.proc('eval task', task.id, task.name,task.completed,task.source,self.name(), task)
                }
                if (task.completed == true) {
                    if ( debugTaskProcessing ) {   self.proc(starter,'task completed') }
                    //if task originated from me
                    if (task.source == self.name()) {
                        //if i did not process this task
                        if (task.processor != self.name()) {
                            self.taskCleanUp(task.taskResult)
                        }
                        if ( debugTaskProcessing ) {   self.proc(starter,'removing task') }
                        return;
                        //remove ....
                    } else {

                    }
                }

                //if task is new
                if (task.started == false) {
                    if ( debugTaskProcessing ) {   self.proc(starter, 'task not started') }
                    //if i am not the source
                    if (task.source != self.name()) {
                        debug.taskStarted=true
                        self.startTask(task)
                    }
                    //if i am supposed to do it
                    if (task.target == self.name()) {
                        self.startTask(task)
                    }
                }

                if ( debug.client == false ) {
                    if (task.started &&  task.processor == null && task.taskResult == null) {
                        throw 'taskResult should have been set'
                    }
                    if (task.started && task.processor == null) {
                        // throw 'task needs processor'
                        self.proc('removeTask', task.id, 'task has no processor but is started')
                        return;
                    }

                    //clean tasks, test to remove invalide tasks
                    if (task.processor == self.name()) {
                        if (task.taskResult == null ) {
                            self.proc(task.id, 'task is invalid', 'i am not processing it', 'remove')
                            return; //
                        }
                        if (task.processor_id != self.actor.id ) { //do not accept-tasks
                            self.proc(task.id, 'task is not form my instance', 'i am not processing it', 'remove')
                            return; //
                        }
                        //remove tasks that might be stale and should be removed
                        if ( task.completed == false ) {
                            if (task.taskResult.task.verify != null && task.taskResult.task.verify() == false) {
                                return; //
                            }
                        }
                    }
                }

                filteredTasks.push(task)

            })

            var changed = false
            if (self.actor.model.tasks.length != filteredTasks.length) {
                changed = true
            }

            self.actor.model.tasks = filteredTasks;
            if ( debugTaskProcessing ) {  console.log() }
            if (changed) {
                self.actor.syncModel();
            }
            self.actor.actor.checkModel();
        }

        /**
         * Remove any tasks that are mine
         * @param clonedModel
         */
        p.utils.filterTasksForSend = function filterTasksForSend(clonedModel) {
            var filteredTasks  = []
            function removeMyTasks() {
                if ( task.processor == self.name() ) {
                    return true
                }
                return false;
            }
            filteredTasks = clonedModel.tasks.filter =  removeMyTasks;

            return filteredTasks;
        }

        /**
         * Prevent json circular references by removing this ...
         * @param clonedModel
         */
        p.utils.removeModelForSend = function removeModelForSend(  taskList) {
            self.removeModelOldData = []; //feature, do not send data down
            taskList = sh.defaultValue(taskList, self.actor.model.tasks)
            sh.each(taskList, function filterTasks(i, task){
                if ( task.taskResult != null ) {
                    task.taskResult.task.model = null;
                    task.taskResult.task.actor = null;
                    task.taskResult.task.yyyyyyyyyyyyyyyy = '55555';
                    self.removeModelOldData.push(task.taskResult.task.data);
                    task.taskResult.task.data = null;
                    task.data = null;

                }
            })
            self.actor.actor.checkModel();
            function reverseRemoveModelForSend() {
                sh.each(taskList, function filterTasks(i, task){
                    if ( task.taskResult != null ) {
                        /*  try {
                         //   self.proc(self.name, JSON.stringify(task))}
                         catch ( e ) {
                         //     throw e
                         //     console.log('d', task.taskResult.task ) //.settings.name)
                         }*/
                        task.taskResult.task.model = self.actor.model;
                        task.taskResult.task.actor = self.actor;

                        task.taskResult.task.jjjjjjjjjjjjjj = '67567';
                        task.taskResult.task.data = self.removeModelOldData[i];
                        task.data = task.taskResult.task.data;

                    }
                })
            }
            self.actor.actor.checkModel();
            return reverseRemoveModelForSend;
        }

        /**
         * Only called after above function
         */
        p.utils.replaceMocdelForSend = function removeModelForSend() {

            sh.each(self.actor.model.tasks, function filterTasks(i, task){
                if ( task.taskResult != null ) {
                    task.taskResult.task.model = self.actor.model;
                    task.taskResult.task.actor = self.actor;
                    task.taskResult.task.data = self.removeModelOldData[i];
                    task.data = task.taskResult.task.data;
                }
            })
        }





    }
    filterTasks()

    p.startTask = function startTask(task) {
        self.actor.actor.checkModel();
        var taskType = self.data.dictTaskTypes[task.name];
        var cmdSettings = self.data.dictTaskTypesSettings[task.name];
        if ( taskType != null ) { //expect type to have an execute method
            task.started = true;
            var runTask = new taskType()
            runTask.data = task.data;
            runTask.model = self.actor.model;
            runTask.actor = self.actor;
            runTask.properties = cmdSettings.cmdProperties; //properties?

            var taskResult = {}
            taskResult.id = task.id;
            //model.session_task++
            //taskResult.session_task = model.session_task;
            //self.task_id++
            //taskResult.initTask = task;
            taskResult.taskType = task.name;
            //taskResult.taskDef = taskType;
            taskResult.task = runTask;  //TODO Remove ... possibly for bad task
            //taskResult.d = 7;
            taskResult.success = false;
            //taskResult.originalTaskRequest = task;

            task.processor = self.name();
            task.processor_id = self.actor.id;

            task.parentModelId = self.actor.model.id;

            task.taskResult = taskResult;

            var fxFailure = function fxFailure(errorIfDefined) {
                taskResult.error = errorIfDefined;
                self.taskFailure( taskResult )
                self.finishTask(task)
            }
            var fxSuccess = function fxSuccess(data) {
                self.proc('done with task', task.id, task.name)
                taskResult.success = true;
                taskResult.data = data;
                task.data = data; ///? for sending up ...?
                self.taskSuccess( taskResult )
                self.finishTask(task)
            }
            runTask.fail = fxFailure
            runTask.success = fxSuccess
            runTask.done = fxSuccess
            runTask.ok = fxSuccess


            //send message to ui
            function addUpdateDown(x) {
                if ( task.outgoing == null ) {
                    task.outgoing = [];
                }
                task.outgoing.push(x)
            }
            runTask.addUpdateDown = addUpdateDown

            //bookmark
            //it is the processors responsibility to timeout commands
            var timeCommandTimeoutWarning = self.settings.timeCommandTimeoutWarning;
            var timeCommandTimeoutFailure = self.settings.timeCommandTimeoutFailure;
            //overrides
            if ( task.timeCommandTimeoutWarning != null ) {
                timeCommandTimeoutWarning = task.timeCommandTimeoutWarning
            }
            if ( task.timeCommandTimeoutFailure != null ) {
                timeCommandTimeoutFailure = task.timeCommandTimeoutFailure
            }
            if (timeCommandTimeoutWarning!=null){
                setTimeout(function timeoutCommandWarning(){
                    self.proc('command is taking too long', taskResult.taskType)
                }, timeCommandTimeoutWarning)
            }
            if (timeCommandTimeoutFailure!=null){
                setTimeout(function timeoutCommandWarning(){
                    self.proc('command has timed out', taskResult.taskType)
                    runTask.fail(types.TIMEOUT);
                }, timeCommandTimeoutFailure)
            }
            //start timer to warn user of long uncompleted commands ...
            //if try catch

            if ( cmdSettings.cmdProperties.noTryCatch || self.actor.testMode ) {
                runTask.execute();
                return;
            }

            try {
                runTask.execute();
            } catch ( e ) {
                taskResult.stack = e.stack;
                taskResult.errorMessage = e.message;
                console.error('running command', e, e.stack, e.message)
                fxFailure(e)//fxFailure(task)
            }
            //success ... failure?
        }
    }

    p.endStaleTask = function endStaleTask(task){
        if ( task.source == self.name() ){

        } else {
            return;
        }
        self.finishTask(task);
        if ( task.taskResult != null ) {
            self.taskFailure(task.taskResult)
        }
    }

    p.finishTask = function finishTask(task) {
        task.completed = true
        //task.timeStop = new Date()
        task.timeStop = new Date().getTime();
        var startTime = new Date()
        startTime.setTime(task.timeStart)
        task.duration = sh.timeElapsed(startTime);
        self.proc('command took', task.duration)
        self.data.finishedTasks.push(task);
    }

    p.taskFailure = function taskFailure(taskResult ) {
        console.log(taskResult.task.name, sh.paren(taskResult.taskType), 'failed', sh.paren(self.settings.name))
        self.taskCleanUp(taskResult)
        return;
        if (taskResult.error == types.TIMEOUT) {
            return; //not implemented yet
            //command has timed out ...
            //look for retry requests
            var retryAttempts = self.utils.getPropertyFromSettingThenFromTask('retryAttempts', taskResult.originalTaskRequest)
            var retryAttempt = taskResult.retryAttempt
            if ( retryAttempt < retryAttempts ) {
                var taskToReplay = taskResult.originalTaskRequest;
                taskToReplay.retryAttempt++
                taskToReplay.prevAttempts=[taskToReplay]
                startTask(taskToReplay)
            }
        }
        return;

    }

    p.taskSuccess = function taskSuccess(taskResult ) {
        console.log(taskResult.task.name, sh.paren(taskResult.taskType), 'succeeded', sh.paren(self.settings.name))
        self.taskCleanUp(taskResult)
        return;
    }


    p.taskCleanUp = function taskCleanUp(taskResult) {
        var id = taskResult.id;
        console.log(taskResult.id,taskResult.task.name,
            taskResult.task.desc, sh.paren(taskResult.taskType), 'clean up', sh.paren(self.settings.name))

        var fxDone = self.data.dictTaskToFx[id];
        console.log(id,self.data.dictTaskToFx )
        self.data.dictTaskToFx[id] = null
        if ( fxDone != null ) {
            if ( taskResult.success ) {
                fxDone(taskResult.data, true, taskResult)
            } else {
                self.proc('error in task', id, taskResult.error)
                console.log('error processing task', taskResult)
                fxDone(taskResult.error, false, taskResult)
            }

        }
    }


    /*

     p.addTask = function addTask(taskName, data, fxDone, desc) {
     var task = {}
     task.id = new Date().getTime();
     task.source = self.name
     task.name = taskName;
     task.data = data;
     task.desc = desc;
     if ( fxDone != null ) {
     self.dictTaskToFx[id] = fxDone;
     }
     task.timeStart = new Date();
     //if ( self.model.tasks == null ) {
     //    self.model.tasks = []
     //}
     self.actor.model.tasks.push( task);
     self.pushModel();
     return task;
     }
     */

    /**
     * Register the
     * @param type
     * @param clazz
     */
    p.addTaskType = function addTaskType(type, clazz, cmdProperties) {
        if ( clazz == null ) {
            clazz = GenericCommandExample
        }
        self.data.dictTaskTypes[type] = clazz;
        var cmdSettings = {}
        cmdSettings.cmdProperties = cmdProperties;
        self.data.dictTaskTypesSettings[type] = cmdSettings;
    }
    p.addTask = function addTask(taskName, data, fxDone, desc, target) {
        var taskSettings = {} ;
        taskSettings.taskType = taskName
        taskSettings.data = data
        taskSettings.fxCallback = fxDone
        taskSettings.desc = desc
        taskSettings.target = target
        return  self.createTask(taskSettings)
    }
    p.createTask = function createTask(newTaskSettings) {
        if ( self.actor.taskCount == null ) {
            self.actor.taskCount = 0;
        }
        var nTS = newTaskSettings;
        var taskName, data, fxDone, desc, target
        taskName=nTS.taskType; data=nTS.data;
        fxDone=nTS.fxCallback
        desc=nTS.desc
        target=nTS.target;

        if ( taskName == null && nTS.type != null ) {
            taskName = nTS.type;
        }
        if ( taskName == null ) {
            console.error(nTS)
            throw 'do not have task type ' + JSON.stringify(nTS)
        }

        var task = {}
        //task.idx = new Date().getTime();
        self.actor.taskCount++;
        task.id = self.settings.name+'_'+self.actor.taskCount;

        task.source = self.settings.name;
        task.name = taskName;
        task.data = data;
        task.desc = desc;
        if ( fxDone != null ) {
            self.data.dictTaskToFx[task.id] = fxDone;
        }

        self.data.dictTaskIdToSettings[task.id] = nTS;

        task.timeStart = new Date().getTime();
        task.timeStartH = sh.getTimeStamp();
        task.started = false;
        //if ( self.model.tasks == null ) {
        //    self.model.tasks = []
        //}

        //request a specific processor
        if ( target != null ) {
            task.target = target;
        }
        //this is a task i will do myself ... do not route it.
        if ( target == true ) {
            task.target = self.settings.name;
        }

        self.actor.model.tasks.push( task);
        self.processTasks() //clear any tasks before sending update
        if( self.settings.pushAfterTasks != false ) {
            self.actor.pushModel();
        }

        task.incoming = [];
        task.outgoing = [];
        //want to make this an object ... but want it to be serializable
        task.addUpdate = function addUpdate(update){
            task.incoming.push(update)
            return update;
        }
        return task;
    }

    p.hasTask = function hasTask(taskId){
        sh.each(self.actor.model.tasks, function filterTasks(i, task){
            if ( task.id == taskId ) {
                self.proc('found the task');
            }
        })

    }

    function defineCreateTasks() {
        p.utils.copyInTasks = function copyInTasks(oldTasks_, newTasks_) {
            function selftaskstaskDict(tasks) {
                if ( tasks == null ) {
                    self.proc('no tasks')
                    return {}
                }
                var dict = {}
                sh.each(tasks, function filterTasks(i, task){
                    dict[task.id] = task;
                })
                return dict;
            }

            var oldTasks = selftaskstaskDict(oldTasks_)
            var newTasks = selftaskstaskDict(newTasks_)

            var newTaskList = []
            sh.each(newTasks, function filterTasks(id, newTask){
                var oldTask = oldTasks[id]
                oldTasks[id]=null;
                //add any new ids
                if ( oldTask == null ) {
                    newTaskList.push(newTask)
                    return;
                }
                //i update mine
                if (oldTask.source == self.name() ) {
                    var incoming = oldTask.incoming;
                    sh.mergeObjects(newTask,oldTask)
                    oldTask.incoming = incoming;
                    newTaskList.push(oldTask)
                    //feature: send recieved outgoingMessages from processor
                    function handleTaskOutgoingMessages() {
                        //feature: taskchannel - update incoming
                        //oldTask.incoming = newTask.incoming;
                        var liveCommandRef = oldTask.taskResult.task
                        var settings = self.data.dictTaskIdToSettings[oldTask.id]
                        if (settings == null ||
                            settings.fxUpdate == null) {
                            return;
                        }
                        if (newTask.outgoing == null) {
                            return
                        }
                        if (newTask.outgoing.length > 0) {
                            self.proc('sending','outgoing', newTask.outgoing.length, 'messages')
                        }
                        sh.each(newTask.outgoing, function sendEachoutgoinMessageToTask(i, message) {
                            settings.fxUpdate(message)
                        })
                    }
                    handleTaskOutgoingMessages()


                    return
                }
                //oldTasks[id] = newtask;
                newTaskList.push(newTask)
                return;
                //return x;
            })


            //important: without this step, a client can send an empty task array and clear
            //all the server's tasks
            sh.each(oldTasks, function processOldTaskTheClientDidNotPost(i,task){
                if ( task != null ) {
                    //purge stale tasks
                    //old task was not sent from server
                    if ( task.processor != self.name() && self.client() && self.actor.model.id !=  task.parentModelId){
                        if ( task.started ) {
                            console.log('purging my old tasks')
                            self.endStaleTask(task); //notify m of failure
                            return;
                        }

                    }
                    //remove tasks that are complete
                    if ( task.completed == true ){
                        if ( task.started ) {
                            console.log('purging my old tasks')
                            self.endStaleTask(task); //notify m of failure
                            return;
                        }

                    }
                    newTaskList.push(task)
                }
            })

            if ( newTaskList.length > oldTasks_.length+newTasks_.length ) {
                throw 'mismatch on new size'
            }

            //self.model = newModel;
            return newTaskList;
        }


        /**
         * Called after update ... clear incomign messages
         * @param tasks
         * @returns {*}
         */
        p.utils.removeAllIncomingMessages = function removeAllIncomingMessages(tasks) {
            sh.each(tasks, function filterTasks(id, oldTask){
                //i update mine
                if (oldTask.source == self.name() ) {
                    oldTask.incoming = [];
                    //feature removed ...
                }
            })

            //self.model = newModel;
            //return newTaskList;
        }


        /**
         * Called after update ... clear incomign messages
         * @param tasks
         * @returns {*}
         */
        p.utils.removeAllOutgoingMessages = function removeAllOutgoingMessages(tasks) {
            sh.each(tasks, function filterTasks(id, oldTask){
                //i update mine
                if (oldTask.processor == self.name() ) {
                    oldTask.outgoing = [];
                    //feature removed ...
                }
            })

            //self.model = newModel;
            //return newTaskList;
        }







        /**
         */
        p.utils.getTask = function getTask(typeFilter, includeIncomplete) {
            var foundMatch = null
            sh.each(self.actor.model.tasks, function filterTasks(id, oldTask){
                //i update mine
                //if (oldTask.processor == self.name() ) {
                if(  sh.isString( typeFilter))  {
                    if (oldTask.name == typeFilter) {
                        foundMatch = oldTask
                        return false
                    }
                }
                else {
                    var query = typeFilter
                    sh.each(query, function handleProp(i, val ){
                        if ( oldTask[i] == val) {
                            foundMatch = oldTask
                        } else {
                            foundMatch = null
                            return false
                        }
                    })
                    if ( foundMatch ) {
                        return false;
                    }
                }

            })


            if (foundMatch != null ) {
                //bookmark: dress up client side task to behave like
                //task client crieated
                if ( foundMatch.incoming == null ) {
                    foundMatch.incoming = [];
                }
                if ( foundMatch.addUpdate == null ) {
                    //foundMatch.outgoing = [];
                    //want to make this an object ... but want it to be serializable
                    foundMatch.addUpdate = function addUpdate(update) {
                        task.incoming.push(update)
                        return update;

                    }
                }
            }


            return foundMatch;
            //self.model = newModel;
            //return newTaskList;
        }
    }
    defineCreateTasks()
    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }

}


if ( sh.isNode ) {

    if (module.parent == null) {

    }

    exports.TaskManager = TaskManager;
    exports.Task = Task;

}