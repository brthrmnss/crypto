/**
 * Created by smorris1 on 1/3/14.
 *
 *
push
 pull
 runcommand, name, data, callback
 singletone mode
 *
 */

/*
function BolideUIClientUI() {
    var p = BolideUIClientUI.prototype;
    p = this;
    var self = this;
    self.notifier = new EventEmitter()
    self.notifier.modelUpdated = function modelUpdated() {

    }

    self.tasks = new TaskManager();
    self.tasks.source = 'client';

    p.loadSettings = function loadSettings(config){

        var configFilePath = null;
        if ( config != null ) {
            configFilePath = config.file;
        }
        //load file and populate settings object
        //self.taskManager = new TaskManager();

        var defaultSettings = {}
        defaultSettings.allowedTasks = []
        defaultSettings.fxDetermineUserType
        defaultSettings.fxCanUserCreateTasks
        defaultSettings.fxCreateTask
        defaultSettings.timeoutTimeTasks = 60
        defaultSettings.maxTasksPerUser
        defaultSettings.name = 'unamed model'
        defaultSettings.port = 7788

        defaultSettings.autoStart = true;



        //load config
        var settingsHelperConfig = {}
        settingsHelperConfig.file = configFilePath;
        settingsHelperConfig.defaultSettings = defaultSettings;
        //settingsHelperConfig.arrayFields = ['skipRequests', 'skipRemotes']
        //settingsHelperConfig.objectFields = ['intercept/']

        //settingsHelperConfig.searchPaths = null;//
        settingsHelperConfig.fxResult = self.processSettings
        self.helper = SettingsHelper.LoadSettings(settingsHelperConfig);
        //JSON_Party_Save_Personal.har noChanges.json n1 PARTY westwest Test1234 1234 09174445

    }

    p.processSettings = function processSettings(settings) {
        //handle preset modes
        //if ( mode == 'download' ) {
        //    settings.saveRequests = true;
        //}
        self.proc('options', settings)
        self.settings = settings;

        //go to original settings
        self.postProcessSettings(settings)
    }
    p.postProcessSettings = function postProcessSettings(settings) {
        //self.model.settings = defaultSettings;

        self.model = {}
        self.model.name = settings.name;
        self.model.id = new Date().getTime();
        self.model.revision_id = 0;
        self.model.revision_id_ui = 0;
        self.model.revision_id_remote = 0

        self.model.changesLog = {}

        *//*if ( self.settings.autoStart ) {
         self.startExpressServer();
         }*//*

        sh.callIfDefined(self.fxStarted)
    }


    p.pushModel = function pushModel(fxDone) {

        var options = {}
        options.url = 'http://localhost:'+self.settings.port;
        options.url += '/pushModel'
        options.method = 'POST'
        self.model.revision_id_ui++;
        options.form = self.model;
        request(options, fxCallback)

        function fxCallback(error, response, body) {

            var model_ = JSON.parse(body);
            self.model = model_;
            console.log(options.url, body)
            if (fxDone != null) {
                fxDone(self.model);
            }
            self.notifier.modelUpdated();
            return;
        }
    }

    p.pullModel = function pullModel(fxDone) {

        var options = {}
        options.url = 'http://localhost:'+self.settings.port;
        options.url += '/pullModel'
        request(options, fxCallback)

        function fxCallback(error, response, body) {

            console.log(options.url, body)
            var model_ = JSON.parse(body);
            self.model = model_;
            if ( fxDone != null ) {
                fxDone(model_)
            }
            self.notifier.modelUpdated();
            return;

            try {
                var jsonBack = JSON.parse(body)
            } catch (e) {
                console.log("can't convert to json", entry.request.url)
            }
            //console.log("json sent up", sh.toJSONString(requestOptions.form));
            //console.log("json sent back", sh.toJSONString(jsonBack))
            origReq.newResponse = body; //store new request
            console.log(requestOptions.url);
            if (  self.settings.showRequestBodies ) {
                self.proc('body', body)
            }
            if (  self.settings.saveRequests == true  ) {
                self.downloadGetContentPost(entry, body, requestOptions.url)
            }
            var json = {};
            try {
                json = JSON.parse(body);
                // Verify the changes were made
                self.modifyVerifyJson(json, origReq.url.substr(origReq.url.indexOf(".com")+5), false);
            } catch (e) {
                self.proc('cant make json');
                console.log(url, body, error)
                setTimeout(function delay() {}, 2000)
                console.error("Could not verify changes.");
            }

            // Verify the changes were made
            //self.modifyVerifyJson(json, origReq.url.substr(origReq.url.indexOf(".com")+5), false);

            var hasError = false;
            if ( json.messages != null && json.messages.length > 0 ) {
                hasError = true;
                console.log('error', requestOptions.url );
                sh.each(json.messages , function (i, message) {
                    console.error('error', message.detailMessage);
                    if(message.messageText) console.error('error', message.messageText);
                    if(message.status == "WARNING") {
                        console.error("JSONTESTWARNING");
                    } else {
                        console.log("JSONTESTFAILED");// send the signal to the test runner that the test failed
                    }
                });
                //console.log("JSONTESTFAILED"); // send the signal to the test runner that the test failed
            }
            var likelyErrorFromResponse = sh.callIfDefined(fxFilterLikelyFailedRequest, response);
            var likelyErrorFromBody = sh.callIfDefined(fxFilterLikelyFailedRequestBody, body);

            if (stopOnError && error != null ) {
                console.error(error, error.stackTrace, error.message);
                throw 'error'
            }
            if (stopOnError && hasError ) {
                setTimeout(function err() {throw 'error'}, 500 );
                return
            }

            fxIterationComplete();
        }

    }


    p.method1 = function method1(url, appCode) {
    }

    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }


    if ( isJQueryAvailable) {

    }
}*/

/**
 * Static mode. Made for quick testing and mocking
 */
BolideUIClient.createStatic = function createStatic(settings) {
    console.log('start')
    var client = new BolideUIClient();
    if ( settings == null ) {
        settings = {}
        settings.relativeUrls = true
    }
    client.loadSettings(settings)
    BolideUIClient.instance = client
    BolideUIClient.pull = function get(fxDone) {
        client.pullModel(fxDone)
    }
    BolideUIClient.push = function push(fxDone) {
        client.pushModel(fxDone)
    }
    BolideUIClient.runCommand = function runCommand(task, fxDone) {
        client.runCommand(task, fxDone)
    }

    BolideUIClient.addTask = function addTask(task, data, fxDone) {
        client.tasks.addTask(task, data, fxDone)
    }
    BolideUIClient.createTask = function createTask(taskSettings) {
        client.tasks.createTask(taskSettings)
    }

    BolideUIClient.syncContinually  = function syncContinually(time, fxDone) {
        client.syncContinually(time, fxDone)
    }

    client.pullModel(function pullModel(m){
        console.log('pullModel', '...',m)

        client.pushModel(function pushedModel(m){
            console.log('pushedModel', '...',m)

        })
    })


/*
    client.events.bind('modelUpdated', function modelUpdated(){
        BolideUIClientUI.model = instance.model;
    })*/

}


BolideUIClient.createStatic();