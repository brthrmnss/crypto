/**
 * Created by smorris1 on 1/3/14.
 * Encapsulates all loigc for remote server
 */
var sh = require('shelpers').shelpers;
var SettingsHelper = require('shelpers').SettingsHelper;
var ExpressServerHelper = require('shelpers').ExpressServerHelper
var express = require('express')
var TaskManager = require('./TaskManager').TaskManager
var Actor = require('./ActorData').Actor

function BolideServer() {
    var p = BolideServer.prototype;
    p = this;
    var self = this;

    self.data = {}
    self.model = {}

    self.settings = {}

    ////push pull
    /**
     * Receive model
     * @param newModel
     */
    p.receieveModel = function receieveModel(newModel) {
        self.actor.checkModel();
        //create list of updates
        self.utils.model.diffModel(newModel)
        self.actor.checkModel();
        self.tasks.processTasks()
        self.model.revision_id_remote++;
    }

    p.pushModel = function pushModel(req, res) {

        var reqBody = req.body;

        self.actor.checkModel();
        self.actor.checkSendableModel(reqBody, false );
        //console.error('rec....', sh.toJSONString(reqBody) )
        if ( reqBody.id == self.model.id ){
            self.receieveModel(reqBody) //TODO: UI is not picking up remoev tasks when starts up late
        } else {
            console.log('bad model id match')
        }
        //reqBody = JSON.parse(reqBody)
        var body = self.pullModel();
        self.actor.checkSendableModel(body)
        res.send(JSON.stringify(body))
        self.tasks.utils.removeAllOutgoingMessages(self.model.tasks)
    }


    /**
     * Get old model
     * @param newModel
     */
    p.pullModel = function pullModel() {


        var fxUndo_removeModelForSend = self.tasks.utils.removeModelForSend()


        var tempModel = self.actor.cleanModelForSend(tempModel)


        fxUndo_removeModelForSend()

        self.actor.checkSendableModel(tempModel)

        //self.tasks.utils.replaceModelForSend();
        return tempModel;
    }

    /**
     * Response to request route
     * @param req
     * @param res
     */
    p.getModel = function getModel(req, res) {
        self.actor.checkModel();
        var model = self.pullModel();
        self.actor.checkSendableModel(model );
        var modelStr = JSON.stringify(model);
        if ( modelStr.length > self.settings.largeModelCharLimit ) {
            self.proc('model is too big')
            if ( self.settings.largeModelDoNotSend == true ) {
                return
            }
        }
        res.end(modelStr)
    }

    p.utils = {}
    p.utils.model = {}
    /**
     * Join models
     * watch out for security stuff
     * @param newModel
     */
    p.utils.model.diffModel = function diffModel(newModel) {
        function selftaskstaskDict(tasks) {
            if ( tasks == null ) {
                self.proc('no tasks')
                return {}
            }
            var dict = {}
            sh.each(tasks, function filterTasks(i, task){
                dict[task.id] = task;
            })
            return dict;
        }

        var oldTasks = selftaskstaskDict(self.model.tasks)
        var newTasks = selftaskstaskDict(newModel.tasks)



        self.actor.checkModel();
        self.actor.checkSendableModel(newModel, false );

        var newTaskList = []
        sh.each(newTasks, processNewTask )



        function processNewTask(id, newTask){
            var oldTask = oldTasks[id]
            oldTasks[id] = null;//

            //drop forien task
            if ( newTask.parentModelId!=null&&newTask.parentModelId != self.model.id) {
                self.proc('removing task that is not paredted by model')
                return
            }

            //add any new ids
            if ( oldTask == null ) {
                //self.model.tasks.push(newtask)
                newTaskList.push(newTask)
                return;
            }

            //i update mine
            if (oldTask.processor == self.settings.name  ) {
                //do accept-tasks that were done by a different instance of 'me'
                if ( oldTask.processor_id != self.id ) {
                    self.proc('removing task that is not mine')
                    return;
                }
                newTaskList.push(oldTask)
                function handleTaskIncomingMessage() {
                    //feature: taskchannel - update incoming
                    //oldTask.incoming = newTask.incoming;
                    var liveCommandRef = oldTask.taskResult.task
                    if (liveCommandRef.incomingMessage == null) {
                        return;
                    }
                    if (newTask.incoming == null) {
                        return
                    }
                    if (newTask.incoming.length > 0) {
                        self.proc('sending', newTask.incoming.length, 'messages')
                    }
                    sh.each(newTask.incoming, function sendEachIincomingMessageToTask(i, message) {
                        oldTask.taskResult.task.incomingMessage(message)
                    })
                }
                handleTaskIncomingMessage()
                return
            }
            //oldTasks[id] = newtask;
            newTaskList.push(newTask)
            return;
            //return x;
        }

        //important: without this step, a client can send an empty task array and clear
        //all the server's tasks
        sh.each(oldTasks, function processOldTaskTheClientDidNotPost(i,task){
            if ( task != null ) {
                //processNewTask(i, task)
                newTaskList.push(task) //this will occur often, as we do not send up
                //tasks that aren't being updated
            }
        })


        var dupeTasks = []
        var filteredTasks_NoDupes = []
        var uniqueIdsForOldTasks = {}
        //important: without this step, a client can send an empty task array and clear
        //all the server's tasks
        sh.each(newTaskList, function removeDupeTasks(i,task){
            if ( uniqueIdsForOldTasks[task.id] != null ) {
                dupeTasks.push(task)
                return; // remove dupe ...
            }
            if ( task.completed == true ) {
                if ( task.send1xAfterComplete == null ||
                    task.send1xAfterComplete < 4 ) {
                    if (  task.send1xAfterComplete == null)
                    task.send1xAfterComplete = 0;

                    task.send1xAfterComplete++

                } else {
                    self.proc('removing an emtpy .. fix ') //TODO
                    return;
                }
            }
            filteredTasks_NoDupes.push(task) //this will occur often, as we do not send up
            //tasks that aren't being updated
            uniqueIdsForOldTasks[task.id] = task;
        })




        self.actor.checkModel();
        self.actor.checkSendableModel(newModel, false );
        self.actor.copyInRecievedModel(newModel)
        self.actor.checkModel();
        /* if ( self.model.tasks == null ) {
         self.model.tasks = [];
         }*/
        self.model.tasks = filteredTasks_NoDupes;

    }

    //bookmark: startup and init
    p.loadSettings = function loadSettings(config){

        var configFilePath = null;
        if ( config != null ) {
            configFilePath = config.file;
        }
        //load file and populate settings object

        var defaultSettings = {}
        defaultSettings.allowedTasks = []
        defaultSettings.fxDetermineUserType
        defaultSettings.fxCanUserCreateTasks
        defaultSettings.fxCreateTask
        defaultSettings.timeoutTimeTasks = 60
        defaultSettings.maxTasksPerUser
        defaultSettings.name = 'server'
        defaultSettings.portProxy = 7788

        defaultSettings.autoStart = true;

//http://localhost:7788/geetGuid3.htm

        //load config
        var settingsHelperConfig = {}
        settingsHelperConfig.file = configFilePath;
        settingsHelperConfig.input = config
        settingsHelperConfig.defaultSettings = defaultSettings;
        //settingsHelperConfig.arrayFields = ['skipRequests', 'skipRemotes']
        //settingsHelperConfig.objectFields = ['intercept/']

        //settingsHelperConfig.searchPaths = null;//
        settingsHelperConfig.fxResult = self.processSettings
        self.helper = SettingsHelper.LoadSettings(settingsHelperConfig);
        //JSON_Party_Save_Personal.har noChanges.json n1 PARTY westwest Test1234 1234 09174445

    }

    p.processSettings = function processSettings(settings) {
        //handle preset modes
        //if ( mode == 'download' ) {
        //    settings.saveRequests = true;
        //}
        self.proc('options', settings)
        self.settings = settings;

        //go to original settings
        self.postProcessSettings(settings)
    }
    p.postProcessSettings = function postProcessSettings(settings) {
        //self.model.settings = defaultSettings;

        //create intial model
        //ftf: how to handle multiple sync zones?
        self.model = {}
        self.model.name = settings.name;

        self.model.revision_id = 0;
        self.model.revision_id_ui = 0;
        self.model.revision_id_remote = 0

        self.model = self.model;
        self.model.changesLog = {}

        settings.modelRef = self.model;

        //dectorate actor for component
        self.actor = new Actor();

        //self.actor.model = self.model;
        self.actor.actor = self;
        ///self.model.server = self.actor; //?
        //self.actor.loadSettings(settings);

        //self.actor.taskManager = new TaskManager();
        // self.actor.taskManager.loadSettings(settings)
        //intial play to put, while being stored
        self.a_id = TaskManager.id;
        self.id = sh.getTimeStamp();
        self.model.id =  self.id;
        defineTaskManager();
        self.model.tasks = [];

        if ( self.settings.autoStart ) {
            self.startExpressServer();
        }
    }


    function defineTaskManager(){
        self.tasks = new TaskManager();
        //self.tasks = new TaskManager();
        self.tasks.name = 'client';
        self.tasks.actor = self;
    }


    function defineModelUpdators() {
        /**
         * Invoked whem model is changed
         * @param model
         * @param fxDone
         */
        self.updatedModel = function updatedModel(model) {
            self.tasks.processTasks();
        }
    }
    defineModelUpdators();


    p.startExpressServer = function startExpressServer() {
        var server = express();
        server.use(express.bodyParser());
        //for testing only
        server.use(express.static('C:/Users/user1/Dropbox/projects/delegation/complete/quickform'));
        // server.use(express.static('C:/Users/user1/Dropbox/projects/delegation/complete/quickform'));
        server.use(express.static(process.cwd()));
        //shelpers
        server.use(express.static(process.cwd()+'/../'));

        var eSH = new ExpressServerHelper()
        eSH.setup(server, null, null,  'serverX', self)
        eSH.startup(function onPreviousInstanceRemoved(){
            server.listen(self.settings.portProxy);
            sh.callIfDefined(self.fxStarted)
            self.started = true;
            self.actor.checkModel()
        }, self.settings.portProxy)

        server.get('/pullModel', self.getModel)
        server.post('/pushModel', self.pushModel)
        //server.post('/pullModel', self.getModel)


    }


    function defineTaskManager(){
        self.tasks = new TaskManager();
        //self.tasks = new TaskManager();
        //self.tasks.name = self.name;
        self.tasks.settings = self.settings;
        self.tasks.actor = self;

    }
    //  defineTaskManager();


    function defineSyncActions(){
        p.syncModel = function syncModel() {
            if ( self.settings.socketMode){

            }
        }

    }
    defineSyncActions();

    p.method1 = function method1(url, appCode) {
    }

    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }


}


if (module.parent == null) {

}


exports.BolideServer = BolideServer;

