/**
 * Created by smorris1 on 1/3/14.
 * Encapsulates all loigc for remote server
 */
var sh = require('shelpers').shelpers;
var Server = require('./BolideServer').BolideServer;
var Client = require('./BolideUIClient').BolideUIClient;

var type = {}
type.tasks  = {}
type.tasks.fiveSecTask = 'fiveSecTask'

var PromiseHelper = require('shelpers').PromiseHelper;
var OptionsHelper = require('shelpers').OptionsHelper
var SettingsHelper = require('shelpers').SettingsHelper

function TemplateCommands() {
    var p = TemplateCommands.prototype;
    p = this;
    var self = this;
    var achievements = [];
    self.achievements = achievements;


    function defineWork() {

        [NodeJSPropScript,'sc1', {file:"test/RequireScriptTest", obj:"RequireScriptTest"}],
            //for testing ... return data property
            [StubCommand,'sc2', {delay:0}],
            [NodeJSChildScript,'sc3', {file:"test/ChildProcessTestScript.js", writeConfig:false} ]//:"RequireScriptTest"}],



        function NodeJSPropScript() {
            var p = NodeJSPropScript.prototype;
            var p = this;
            var self = this;

            self.name = 'NodeJSPropScript'
            self.settings = {}

            p.execute = function execute() {
                //    try {
                var sdf = require('./'+self.properties.file)[self.properties.obj]
                var instance = new sdf()
                //assumes you send callback
                self.data.fxCallback = function commandFinished(json) {
                    self.ok(json)
                }
                instance.loadConfig(self.data)
                // } catch ( e ) {
                //      self.fail(e, e.stack)
                //  }
                return;
            }
        }
        function NodeJSChildScript() {
            var p = NodeJSChildScript.prototype;
            var p = this;
            var self = this;

            self.name = 'NodeJSChildScript'
            self.settings = {}
            p.execute = function execute() {
                var writeConfig = self.properties.writeConfig;
                if ( writeConfig) {
                    //write temp file and pass to script as first arg
                }

                var CommandRunner = sh.CommandRunner
                var cR  = new CommandRunner();
                var settings ={}
                settings.cmd = 'node'
                var pathToScript = __dirname + '/'+self.properties.file;
                settings.args = [pathToScript]
                if ( self.data.args != null ) {
                    //user arguments
                    settings.args = settings.args.concat(self.data.args)
                }
                //mixin arguments
                //self.properties

                var fxCallbackTestComplete = function fxCallbackTestComplete() {
                    console.log('done')
                    self.ok(self.output)
                }
                self.output  = '';
                settings.fxEcho =  function fxEcho(data){
                    self.output += data
                }

                settings.fxCallback = fxCallbackTestComplete
                cR.execute(settings)

            }
        }

        /**
         * For testing, client sends up data with 'output'
         * property.
         * Server taxkes output and sends back that as result
         * @constructor
         */
        function StubCommand() {
            var p = StubCommand.prototype;
            var p = this;
            var self = this;

            self.name = 'StubCommand'
            self.settings = {}

            p.execute = function execute() {
                //self.data
                //self.success();
                var delay = sh.defaultValue(self.properties.delay,0)
                setTimeout(function returnDataOutput () {
                    self.ok(self.data.output);
                }, delay)

                return;
            }
        }

        function VCommand2() {
            var p = VCommand2.prototype;
            var p = this;
            var self = this;

            self.name = 'some random command'
            self.settings = {}

            p.execute = function execute() {
                //self.data
                //self.success();
                setTimeout(function x () {
                    self.ok('555');
                    //only appliest during test...
                    try {
                        c.model = s.model;
                        c.updatedModel();
                    } catch ( e ) {}
                }, 5000)

                return;
            }
        }

        function VCommand2() {
            var p = VCommand2.prototype;
            var p = this;
            var self = this;

            self.name = 'some random command'
            self.settings = {}

            p.execute = function execute() {
                //self.data
                //self.success();
                setTimeout(function x () {
                    self.ok('555');
                    //only appliest during test...
                    try {
                        c.model = s.model;
                        c.updatedModel();
                    } catch ( e ) {}
                }, 5000)

                return;
            }
        }
        self.VCommand2 = VCommand2;
        self.s.tasks.addTaskType('testTask3', VCommand2)
        self.s.tasks.addTaskType(type.tasks.fiveSecTask, VCommand2)

        sh.each(cmds, function registerCmd(i, cmdSettings){
            var cmdClazz = cmdSettings[0];
            var cmdName = cmdSettings[1];
            var cmdProperties = cmdSettings[2];
            self.s.tasks.addTaskType(cmdName, cmdClazz, cmdProperties)
        })

        cb()
    }

    defineWork()

    function defineUtils() {
        p.utils = {}
    }

    defineUtils();

    /**
     * Receive log commands in special format
     */
    p.proc = function proc() {
        sh.sLog(arguments)
    }
}

if (module.parent == null) {


    /* var t = new ServerExample1()
     var options = {}
     options.port = 7789
     t.loadConfig(options);
     return;*/

}


function NodeJSChildScriptV2() {
    var p = NodeJSChildScriptV2.prototype;
    var p = this;
    var self = this;

    self.name = 'NodeJSChildScriptV2'
    self.settings = {}
    //not seralized ....
    self.data = {}

    p.execute = function execute() {
        var writeConfig = self.properties.writeConfig;
        if ( writeConfig != false ) {

            var outputFileName = null;
            var inputConfigFile = null;

            //write temp file and pass to script as first arg
            if ( self.data.input != null ){
                var writeFileSettings = {}
                writeFileSettings.name = self.properties.file+'tmp.config.json'
                writeFileSettings.timestamp = true// = self.settings.outputFile
                writeFileSettings.dir = 'tempConfigs'
                //create output file to store results
                var outputFileName = 'tempResults/'+sh.getTimeStamp()+'.results.json'
                outputFileName = __dirname + '/'+outputFileName
                self.data.input.outputFileName = outputFileName;
                writeFileSettings.obj = self.data.input
                var configFile = sh.writeFile2(writeFileSettings)
                var inputConfigFile =  configFile.filename;
                inputConfigFile = __dirname + '/'+inputConfigFile
            }
        }

        var CommandRunner = sh.CommandRunner
        var cR  = new CommandRunner();
        var settings ={}
        settings.cmd = 'node'
        var pathToScript = __dirname + '/'+self.properties.file;
        pathToScript = sh.replaceBackslash(pathToScript)

        if ( sh.fileExists(pathToScript) == false ) {
            throw ['can\'t find scrpit ',pathToScript ,
                ' ' ,   __dirname + '/'+self.properties.file].join(" \n ");
        }
        settings.args = [pathToScript]
        if ( self.data.args != null ) {
            //user arguments
            settings.args = settings.args.concat(self.data.args)
        }
        //first parameter is path to input file
        if (inputConfigFile!= null) {
            settings.args = settings.args.concat(inputConfigFile)
        }
        //mixin arguments
        //self.properties

        var fxCallbackTestComplete = function fxCallbackTestComplete() {
            console.log('done')

            if ( outputFileName == null ) {
                self.ok(self.output)
            } else { //handle
                var didOutputFileGetCreated = sh.fileExists(outputFileName);
                if ( didOutputFileGetCreated ) {
                    var output = sh.readFile(outputFileName)
                    var json = null;
                    try {
                        var json = JSON.parse(output)
                    } catch ( e ) {
                        var content = {}
                        content.error = 'Cannot decode json'
                        content.message =   e.message;
                        content.stack = e.stack
                        content.jsonString =
                            self.fail(content)
                    }
                    self.ok(json)
                    sh.deleteFile(outputFileName)
                } else { //feature: if script does not complete ... you get output file
                    var content = {}
                    content.error = self.output
                    self.fail(content)
                }
                //remove temp files ....

                sh.deleteFile(inputConfigFile)
            }
        }
        //why: do not log huge log files
        if ( self.properties.doNotLog != false  ) {
            self.output  = '';
            settings.fxEcho =  function fxEcho(data) {
                self.output += data
            }
        }

        settings.fxCallback = fxCallbackTestComplete;

        settings.fxEcho = function fxEcho(x){
            //console.log('echoing....',x)
            self.addUpdateDown('echo ' + x )
        } //= self.incomingMessage

        //just in case dev has relative load paths
        var scriptDir = sh.dirname(pathToScript)
        process.chdir(scriptDir);
        self.data.cmd = cR;
        cR.execute(settings)
        process.chdir(__dirname);


    }

    p.incomingMessage = function incomingMessage(message) {
        //console.log('incomignmessage', message)
        //self.addUpdateDown('echo ' + JSON.stringify(message) )
        if ( message.type == 'method'){
            //how to send to thing? ....
            ///ugh need another interface ....
            self.data.cmd.write(JSON.stringify(message))
        }
        return;
    }

    p.verify = function verifyIfCmdIsStillRunning() {
        if ( self.data.cmd == null ) {
            self.proc('cannot see command')
            return false;
        }

        try {
            if (self.data.cmd != null) {
                self.data.cmd.write('u there?')
            }
        } catch ( e ) {
            console.error('cmd is not active, terminating')
            return false;
        }

        return true;
    }



    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }
}

exports.NodeJSChildScriptV2 = NodeJSChildScriptV2

function NodeJSInnerScript() {
    var p = NodeJSInnerScript.prototype;
    var p = this;
    var self = this;

    self.name = 'NodeJSPropScript'
    self.settings = {}

    p.execute = function execute() {

        var pathToScript = __dirname + '/'+self.properties.file;
        //just in case dev has relative load paths
        var scriptDir = sh.dirname(pathToScript)
        process.chdir(scriptDir);


        var sdf = require('./'+self.properties.file)[self.properties.obj]
        var instance = new sdf()
        //assumes you send callback
        self.data.fxCallback = function commandFinished(json) {
            self.ok(json)
        }
        var configData = self.data;
        if ( configData.input != null ) {
            configData = configData.input;
        }
        self.addUpdateDown('echo STARTED CMD'   )

        instance['fxEcho'] = self.addUpdateDown ;
        instance['fxExit'] = self.ok ;

        instance.loadConfig(configData)
        self.data.instance = instance;


        // } catch ( e ) {
        //      self.fail(e, e.stack)
        //  }
        process.chdir(__dirname);
        return;
    }


    p.incomingMessage = function incomingMessage(message) {
        //console.log('incomignmessage', message)
        //self.addUpdateDown('echo ' + JSON.stringify(message) )
        if ( message.type == 'method'){
            var fx = self.data.instance[message.methodName]
            fx.apply(self.data.instance, message.args)
        }
        if ( message.type == 'store') {
            if ( self.data.store == null ) { self.data.store={} }
            self.data.store[message.key] = message.val
        }
        if ( message.type == 'echo') {
            //w: added for testing ... devs and verify command is being processed
            self.proc('echo ' + JSON.stringify(message))
            self.addUpdateDown( JSON.stringify(message))// STARTED CMD'   )
        }
        return;
    }


    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }
}

exports.NodeJSInnerScript = NodeJSInnerScript




function OpenUrl() {
    var p = OpenUrl.prototype;
    var p = this;
    var self = this;
    self.name = 'OpenUrl';
    self.settings = {};
    self.data = {};

    p.execute = function execute() {
        var open = require('open');
        var url = self.data.url
        if (self.properties.url != null ) {
            url =   self.properties.url
        }
        open(url)
    }

}

exports.OpenUrl = OpenUrl
