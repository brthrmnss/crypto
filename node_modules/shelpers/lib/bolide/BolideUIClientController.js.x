/**
 * Created by smorris1 on 1/3/14.
 */
var sh = require('shelpers').shelpers;
var SettingsHelper = require('shelpers').SettingsHelper;
var ExpressServerHelper = require('shelpers').ExpressServerHelper
var TaskManager = require('./TaskManager').TaskManager
var request = require('request');
var request = request.defaults({jar: true});
var EventEmitter = require('events').EventEmitter;

function BolideUIClientController() {
    var p = BolideUIClientController.prototype;
    p = this;
    var self = this;
    self.notifier = new EventEmitter()
    self.notifier.modelUpdated = function modelUpdated() {

    }

    self.tasks = new TaskManager();
    self.tasks.source = 'client';

    p.loadSettings = function loadSettings(config){

        var configFilePath = null;
        if ( config != null ) {
            configFilePath = config.file;
        }
        //load file and populate settings object
        //self.taskManager = new TaskManager();

        var defaultSettings = {}
        defaultSettings.allowedTasks = []
        defaultSettings.fxDetermineUserType
        defaultSettings.fxCanUserCreateTasks
        defaultSettings.fxCreateTask
        defaultSettings.timeoutTimeTasks = 60
        defaultSettings.maxTasksPerUser
        defaultSettings.name = 'unamed model'
        defaultSettings.port = 7788

        defaultSettings.autoStart = true;



        //load config
        var settingsHelperConfig = {}
        settingsHelperConfig.file = configFilePath;
        settingsHelperConfig.defaultSettings = defaultSettings;
        //settingsHelperConfig.arrayFields = ['skipRequests', 'skipRemotes']
        //settingsHelperConfig.objectFields = ['intercept/']

        //settingsHelperConfig.searchPaths = null;//
        settingsHelperConfig.fxResult = self.processSettings
        self.helper = SettingsHelper.LoadSettings(settingsHelperConfig);
        //JSON_Party_Save_Personal.har noChanges.json n1 PARTY westwest Test1234 1234 09174445

    }

    p.processSettings = function processSettings(settings) {
        //handle preset modes
        //if ( mode == 'download' ) {
        //    settings.saveRequests = true;
        //}
        self.proc('options', settings)
        self.settings = settings;

        //go to original settings
        self.postProcessSettings(settings)
    }
    p.postProcessSettings = function postProcessSettings(settings) {
        //self.model.settings = defaultSettings;

        self.model = {}
        self.model.name = settings.name;
        self.model.id = new Date().getTime();
        self.model.revision_id = 0;
        self.model.revision_id_ui = 0;
        self.model.revision_id_remote = 0

        self.model.changesLog = {}

        /*if ( self.settings.autoStart ) {
         self.startExpressServer();
         }*/

        sh.callIfDefined(self.fxStarted)
    }


    p.pushModel = function pushModel(fxDone) {

        var options = {}
        options.url = 'http://localhost:'+self.settings.port;
        options.url += '/pushModel'
        options.method = 'POST'
        self.model.revision_id_ui++;
        options.form = self.model;
        request(options, fxCallback)

        function fxCallback(error, response, body) {

            var model_ = JSON.parse(body);
            self.model = model_;
            console.log(options.url, body)
            if (fxDone != null) {
                fxDone(self.model);
            }
            self.notifier.modelUpdated();
            return;
        }
    }

    p.pullModel = function pullModel(fxDone) {

        var options = {}
        options.url = 'http://localhost:'+self.settings.port;
        options.url += '/pullModel'
        request(options, fxCallback)

        function fxCallback(error, response, body) {

            console.log(options.url, body)
            var model_ = JSON.parse(body);
            self.model = model_;
            if ( fxDone != null ) {
                fxDone(model_)
            }
            self.notifier.modelUpdated();
            return;

            try {
                var jsonBack = JSON.parse(body)
            } catch (e) {
                console.log("can't convert to json", entry.request.url)
            }
            //console.log("json sent up", sh.toJSONString(requestOptions.form));
            //console.log("json sent back", sh.toJSONString(jsonBack))
            origReq.newResponse = body; //store new request
            console.log(requestOptions.url);
            if (  self.settings.showRequestBodies ) {
                self.proc('body', body)
            }
            if (  self.settings.saveRequests == true  ) {
                self.downloadGetContentPost(entry, body, requestOptions.url)
            }
            var json = {};
            try {
                json = JSON.parse(body);
                // Verify the changes were made
                self.modifyVerifyJson(json, origReq.url.substr(origReq.url.indexOf(".com")+5), false);
            } catch (e) {
                self.proc('cant make json');
                console.log(url, body, error)
                setTimeout(function delay() {}, 2000)
                console.error("Could not verify changes.");
            }

            // Verify the changes were made
            //self.modifyVerifyJson(json, origReq.url.substr(origReq.url.indexOf(".com")+5), false);

            var hasError = false;
            if ( json.messages != null && json.messages.length > 0 ) {
                hasError = true;
                console.log('error', requestOptions.url );
                sh.each(json.messages , function (i, message) {
                    console.error('error', message.detailMessage);
                    if(message.messageText) console.error('error', message.messageText);
                    if(message.status == "WARNING") {
                        console.error("JSONTESTWARNING");
                    } else {
                        console.log("JSONTESTFAILED");// send the signal to the test runner that the test failed
                    }
                });
                //console.log("JSONTESTFAILED"); // send the signal to the test runner that the test failed
            }
            var likelyErrorFromResponse = sh.callIfDefined(fxFilterLikelyFailedRequest, response);
            var likelyErrorFromBody = sh.callIfDefined(fxFilterLikelyFailedRequestBody, body);

            if (stopOnError && error != null ) {
                console.error(error, error.stackTrace, error.message);
                throw 'error'
            }
            if (stopOnError && hasError ) {
                setTimeout(function err() {throw 'error'}, 500 );
                return
            }

            fxIterationComplete();
        }

    }


    p.method1 = function method1(url, appCode) {
    }

    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }


}


if (module.parent == null) {

}


exports.BolideUIClientController = BolideUIClientController;

