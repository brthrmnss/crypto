/**
 * Created by smorris1 on 1/3/14.
 */

var express = require('express')
var sh = require('shelpers').shelpers;
var fs = require('fs')
var SettingsHelper = require('shelpers').SettingsHelper
var ExpressServerHelper = require('shelpers').ExpressServerHelper
var PromiseHelper = require('shelpers').PromiseHelper;
var request = require('request')

/**
 *
 * @param portProxy
 * @param endpoints_file - primary endpoint csv from layer 7
 * @param endpoints_backup - backup . ie Teambox is primary, Devshr3 is backup
 * @constructor
 */
function BolideLiteTest( ) {
    var self = this;
    var p = BolideLiteTest.prototype;
    p = this;

    self.data = {}

    /**
     * Load settings file using SettingsHelper
     * @param configFile
     * @param configFileContents - during a reload, specify contents, will
     * override configFile
     */
    p.loadConfig = function loadConfig(configFilePath, configFileContents) {
        //create defaults
        var defaultSettings = {}
        defaultSettings.port = 8001;

        //load config
        var settingsHelperConfig = {}
        //  settingsHelperConfig.file = configFilePath;
        settingsHelperConfig.input = configFilePath;
        settingsHelperConfig.defaultSettings = defaultSettings;
        self.data.configFile = configFilePath;

        //settingsHelperConfig.searchPaths = null;//
        settingsHelperConfig.fxResult = function onSettingsLoadedHandler(settings){
            self.settings = settings;
            self.start();
        }
        self.helper = SettingsHelper.LoadSettings(settingsHelperConfig);
    }

    p.start = function startProxy() {
        var newline = "\n"
        self.proc('startingProxy', self.settings.port,
            self.settings.endpointsFile, self.settings.endpointsBackup)

        var server_ = express();
        server_.use(express.bodyParser());

        //for testing only
        server_.use(express.static('C:/Users/user1/Dropbox/projects/delegation/complete/quickform'));
        // bolide
        server_.use(express.static(process.cwd()));
        //shelpers
        server_.use(express.static(process.cwd()+'/../'));



        var eSH = new ExpressServerHelper()


        eSH.setup(server_, self.settings.exitProcess, self.fxExit,  self.id )

        var BolideLite = require('./BolideLite').BolideLite
        var blL = new BolideLite();
        var taskSettings = {}
        taskSettings.name = 'HARProxyServer'
        taskSettings.file = "../../../../proxy/verifications/har_proxyserver.js"
        taskSettings.obj = 'HARProxyServer'
        taskSettings.app = server_;
        self.taskSettings = taskSettings;
        blL.loadSettings(taskSettings)


        //create HarDOwnload task
        var harReaderTask = new BolideLite();
        var taskSettings = {}
        taskSettings.name = 'HARReader'
        taskSettings.file = "../../../../proxy/verifications/HARReader.js"
        taskSettings.obj = 'HARReader'
        taskSettings.app = server_;
        self.taskHarReaderSettings = taskSettings;
        harReaderTask.loadSettings(taskSettings)

        eSH.startup(function onPreviousInstanceRemoved(){
            self.proc('starting', self.id )
            var server = server_.listen(self.settings.port);
            eSH.server = server;
            sh.callIfDefined(self.settings.fxCallbackTestComplete)
           /* if ( self.settings.openUrl ) {*/
                self.launch()
        /*    }*/
            if ( self.settings.test != false  ) {
                self.testTask()
            }
        }, self.settings.port)




    }


    function defineWork() {

        self.testTask = function testTask() {
            var options = {}
            var token = sh.clone(options)
            token.prePrepend = 'http://'+ 'localhost'+':'+self.settings.port +
                '/' + self.taskSettings.name + '/'
            self.token = token

            var work = new PromiseHelper();
            work.name = 'Test Chain'
            work.wait = token.simulate==false;
            work.startChain(token)
                .add(self.startTask)
                .add(self.sendMethod)
                .add(self.updateTask)
                .add(self.getResults)
                .add(self.updateNonSync)
                .end();
        }

        p.startTask = function startTask(token, cb) {
            var options = {}
            options.method = 'POST'
            options.url = 'http://'+ 'localhost'+':'+self.settings.port +
                '/' + self.taskSettings.name + '/' + 'run'

            var form = {}
            var settings = {}
            settings.harFile='C:/Users/user1/Dropbox/projects/crypto/proxy/verifications/shahankpayrollfix.2.c'
            settings.harFileBaseDir = 'c:/trash/harfiles'
            settings.portProxy=6688
            settings.launchUrl = false;
            settings.exitProcess = false;

            //settings.openUrl=true
            form.input = settings
            options.form = form
            request(options, function onServerStarted   (error, response, body)  {
                self.proc(body)
                cb( )
                //
                ///open('http://localhost:7789/geetguid3.htm')
            } )

        }

        p.sendMethod = function sendMethod(token, cb) {
            var options = {}
            options.method = 'POST'
            options.url = token.prePrepend+ 'method'

            var form = {}
            form.method = 'testMeth'
            form.args=  [9]
            options.form = form
            request(options, function onServerStarted   (error, response, body)  {
                self.proc(body)
                if ( error != null ) {
                    throw new Error(error)
                }
                cb()
            } )

        }


        p.sendMethod2 = function sendMethod2(token, cb) {
            var options = {}
            options.method = 'POST'
            options.url = token.prePrepend+ 'method'

            var form = {}
            form.method = 'testMeth'
            form.args=  [9]
            options.form = form
            request(options, function onServerStarted   (error, response, body)  {
                self.proc(body)
                if ( error != null ) {
                    throw new Error(error)
                }
                cb()
            } )

        }

        p.createClient = function createClient(token, cb) {
            c = new Client();
            self.c = c;
            var clientSettings = {}
            clientSettings.name = 'testServerClient'
            clientSettings.port = token.port
            c.loadSettings(clientSettings
            );
            //c.pullModel(function onGotModel(){
            cb()
            //})

        }

        p.defineTasks = function defineTasks(token, cb) {
            //create template system
            var cmds = [
                [NodeJSPropScript,'sc1', {file:"test/RequireScriptTest", obj:"RequireScriptTest"}],
                //for testing ... return data property
                [StubCommand,'sc2', {delay:0}],
                [NodeJSChildScript,'sc3', {file:"test/ChildProcessTestScript.js", writeConfig:false} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSChildScriptV2,'sc4', {file:"/../../../../proxy/swfProxy/EnvCheckerHelper.js"} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSChildScriptV2,'runHarProxy',
                    {file:"../../../../proxy/verifications/har_proxyserver.js"} ],//:"RequireScriptTest"}],
                [TemplateCommands.NodeJSInnerScript,'runHarProxy',
                    {file:"../../../../proxy/verifications/har_proxyserver.js",
                        obj:"HARProxyServer", noTryCatch:false} ],
                [TemplateCommands.OpenUrl,'openUrl', {url:'www.yahoo.com'}  ]
            ]

            function NodeJSPropScript() {
                var p = NodeJSPropScript.prototype;
                var p = this;
                var self = this;

                self.name = 'NodeJSPropScript'
                self.settings = {}

                p.execute = function execute() {
                    //    try {
                    var sdf = require('./'+self.properties.file)[self.properties.obj]
                    var instance = new sdf()
                    //assumes you send callback
                    self.data.fxCallback = function commandFinished(json) {
                        self.ok(json)
                    }
                    instance.loadConfig(self.data)
                    // } catch ( e ) {
                    //      self.fail(e, e.stack)
                    //  }
                    return;
                }
            }
            function NodeJSChildScript() {
                var p = NodeJSChildScript.prototype;
                var p = this;
                var self = this;

                self.name = 'NodeJSChildScript'
                self.settings = {}
                p.execute = function execute() {
                    var writeConfig = self.properties.writeConfig;
                    if ( writeConfig) {
                        //write temp file and pass to script as first arg
                    }

                    var CommandRunner = sh.CommandRunner
                    var cR  = new CommandRunner();
                    var settings ={}
                    settings.cmd = 'node'
                    var pathToScript = __dirname + '/'+self.properties.file;
                    settings.args = [pathToScript]
                    if ( self.data.args != null ) {
                        //user arguments
                        settings.args = settings.args.concat(self.data.args)
                    }
                    //mixin arguments
                    //self.properties

                    var fxCallbackTestComplete = function fxCallbackTestComplete() {
                        console.log('done')
                        // self.ok('ddddd')
                        self.ok(self.output)
                    }
                    self.output  = ''
                    settings.fxEcho =  function fxEcho(data){
                        self.output += data
                    }

                    settings.fxCallback = fxCallbackTestComplete
                    cR.execute(settings)

                }
            }

            /**
             * For testing, client sends up data with 'output'
             * property.
             * Server taxkes output and sends back that as result
             * @constructor
             */
            function StubCommand() {
                var p = StubCommand.prototype;
                var p = this;
                var self = this;

                self.name = 'StubCommand'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    var delay = sh.defaultValue(self.properties.delay,0)
                    setTimeout(function returnDataOutput () {
                        self.ok(self.data.output);
                    }, delay)

                    return;
                }
            }

            function VCommand2() {
                var p = VCommand2.prototype;
                var p = this;
                var self = this;

                self.name = 'some random command'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    setTimeout(function x () {
                        self.ok('555');
                        //only appliest during test...
                        try {
                            c.model = s.model;
                            c.updatedModel();
                        } catch ( e ) {}
                    }, 5000)

                    return;
                }
            }

            function VCommand2() {
                var p = VCommand2.prototype;
                var p = this;
                var self = this;

                self.name = 'some random command'
                self.settings = {}

                p.execute = function execute() {
                    //self.data
                    //self.success();
                    setTimeout(function x () {
                        self.ok('555');
                        //only appliest during test...
                        try {
                            c.model = s.model;
                            c.updatedModel();
                        } catch ( e ) {}
                    }, 5000)

                    return;
                }
            }
            self.VCommand2 = VCommand2;
            self.s.tasks.addTaskType('testTask3', VCommand2)
            self.s.tasks.addTaskType(type.tasks.fiveSecTask, VCommand2)

            sh.each(cmds, function registerCmd(i, cmdSettings){
                var cmdClazz = cmdSettings[0];
                var cmdName = cmdSettings[1];
                var cmdProperties = cmdSettings[2];
                self.s.tasks.addTaskType(cmdName, cmdClazz, cmdProperties)
            })

            cb()
        }

        p.pullModel = function pullModel(token, cb) {
            cb( )
        }

        p.waitStart = function waitStart(token, cb) {

            token.i = setInterval(function tryAGain() {
                if (self.s.started ) {
                    clearInterval(token.i)
                    cb()
                    return;
                }
            },500)

        }


        p.testClientCmds = function testClientCmds(token, cb) {

            c.tasks.addTask('sc2',
                {output:5},
                function fiveSecTaskDone( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }



        p.testClientCmds2 = function testClientCmds2(token, cb) {

            c.tasks.addTask('sc1',
                {output:5},
                function fiveSecTaskDone( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }
        p.testClientCmds3 = function testClientCmds3(token, cb) {

            c.tasks.addTask('sc3',
                {output:5, args:[6666]},
                function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }

        p.testClientCmds_JSONWrittenCommand = function testClientCmds_JSONWrittenCommand(token, cb) {

            c.tasks.addTask('sc4',
                {output:5, input:{env:"n", testUsernames:"nvisioncpa1"}},
                function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done')
                    self.achievements.push('ran and tested a remote task')
                    cb()
                    c.syncStop()
                }
            )

            c.syncContinually(5)

        }
        p.testClientCmds_JSONWrittenCommand_HARProxy = function testClientCmds_JSONWrittenCommand(token, cb) {


            /*  c.tasks.addTask('runHarProxy',
             {output:5, input:{env:"n", harFile:"eam.N.har"}},
             function onCompletedForkedNodeScriptTask( xc, success, result){
             console.log('callback 5 sec task done');
             self.achievements.push('ran and tested a remote task');
             cb();
             c.syncStop();
             }
             )*/

            var taskSettings = {} ;
            taskSettings.taskType = 'runHarProxy'
            taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
            taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
            taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                console.log('callback 5 sec task done');
                self.achievements.push('ran and tested a remote task');
                cb();
                c.syncStop();
            }

            taskSettings.fxUpdate = function onUpdate(x){
                console.log('client', 'got update', x)
            }
            var newTask = c.tasks.createTask(taskSettings);



            sh.wait1Sec(function updateTask(){
                newTask.addUpdate({m:'he'})
            }, 'add update to task to send to remote end')
            sh.waitXSecs(3,function updateTask(){
                newTask.addUpdate({m:'he222'})
                newTask.addUpdate({type:"method",m:'he222'})
            }, 'add update to task to send to remote end 3')

            sh.waitXSecs(4,function updateTask2(){
                newTask.addUpdate({m:'he222'})
                newTask.addUpdate({type:"method",
                    methodName:'testMeth', args:[5,6]})
            }, 'add update to task to send to remote end 3')

            c.syncContinually(1)

        }

        p.testClientCmds_JSONLiveCommand_HARProxy = function testClientCmds_JSONLiveCommand_HARProxy(token, cb) {


            /*  c.tasks.addTask('runHarProxy',
             {output:5, input:{env:"n", harFile:"eam.N.har"}},
             function onCompletedForkedNodeScriptTask( xc, success, result){
             console.log('callback 5 sec task done');
             self.achievements.push('ran and tested a remote task');
             cb();
             c.syncStop();
             }
             )*/

            function runHARTask(){
                var taskSettings = {} ;
                taskSettings.taskType = 'runHarProxy'
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har", exitProcess:false}}
                taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done');
                    self.achievements.push('ran and tested a remote task');
                    cb();
                    //c.syncStop();
                }

                taskSettings.fxUpdate = function onUpdate(x){
                    console.log('client', 'got update', x)
                    if (self.data.runHARTaskMessages==null) {
                        self.data.runHARTaskMessages = []
                    }
                    if ( sh.isString(x) == false ) {
                        x=JSON.stringify(x) //w: for later comparison
                    }
                    self.data.runHARTaskMessages.push(x)
                }

                var newTask = c.tasks.createTask(taskSettings);
                return newTask
            }


            var newTask =  runHARTask()


            //todo ... verify functioning.... that remove is recieving requests
            function sendUpdates() {

                function hasMessage(message, throwError) {
                    message = JSON.stringify(message);
                    if ( sh.includes(self.data.runHARTaskMessages,message)){
                        return true
                    }
                    if ( throwError != false ) {
                        throw new Error('did not receieve a message '+message)
                    }
                    return false;
                }

                sh.waitXSecs(3,function updateTask(){
                    var checkMsg = newTask.addUpdate({m:'he', type:"echo"})
                    sh.waitXSecs(10,function updateTask(){
                        hasMessage(checkMsg)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end')



                //verify messages are being sent
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    var checkMsg = newTask.addUpdate({type:"method",m:'he222', type:"echo"})

                    sh.waitXSecs(5,function updateTask(){
                        hasMessage(667, false)
                        hasMessage(checkMsg, false)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTaskCallMethodToEcho(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:['testMethoEcho']})
                    sh.waitXSecs(5,function verifyMessageReiceved(){
                        hasMessage(["testMethoEcho"])
                        ///>>>
                        restartTask()

                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            sendUpdates()



            function restartTask() {

                sh.waitXSecs(4,function restartHarTask(){
                    var task = self.s.tasks.utils.getTask('runHarProxy')
                    var task_id = task.id;
                    self.data.taskIDOrigHAR = task_id
                    self.proc('restarting server ...')
                    //w:old server will close, providing a lapse with no calllbacks
                    sh.waitXSecs(15,function provideLapseTimeForServerToCatchUp(){
                        self.proc('lapse over')
                        var task = self.s.tasks.utils.getTask({name:'runHarProxy',completed:false}, true)
                        var task_id = task.id;
                        if ( task_id == self.data.taskIDOrigHAR ) {
                            throw new Error('Tasks did not change')
                        }
                    } )

                    try {
                        runHARTask()
                    } catch (  e) {
                        self.proc('error', e)
                    }
                }, 'restart the har task')

                sh.waitXSecs(50,function verifyIdIsChanged(){
                    // self.s.tasks
                }, 'restart the har task...')
            }

            //restartTask()




            function startDownloadTask() {
                sh.wait1Sec(function updateTask(){
                    newTask.addUpdate({m:'he'})
                }, 'add update to task to send to remote end')
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",m:'he222'})
                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTask2(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            //  startDownloadTask()


            cb();
        }

        p.testClientCmds_JSONLiveCommand_HARDownloader = function testClientCmds_JSONLiveCommand_HARDownloader(token, cb) {

            var Task = {}
            Task.HARDownloader = 'harDownloader'
            self.s.tasks.addTaskType('harDownloader', TemplateCommands.NodeJSInnerScript,
                {file:"../../../../proxy/verifications/HARReader.js",
                    obj:"HARReader", noTryCatch:false})

            function runHARDownloaderTask(){
                var taskSettings = {} ;
                taskSettings.taskType = Task.HARDownloader
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har"}}
                taskSettings.data =  {output:5, input:{env:"n", harFile:"eam.N.har", exitProcess:false}}
                taskSettings.fxCallback = function onCompletedForkedNodeScriptTask( xc, success, result){
                    console.log('callback 5 sec task done');
                    self.achievements.push('ran and tested a remote task');
                    cb();
                    //c.syncStop();
                }

                taskSettings.fxUpdate = function onUpdate(x){
                    console.log('client', 'got update', x)
                    if (self.data.runHARTaskMessages==null) {
                        self.data.runHARTaskMessages = []
                    }
                    if ( sh.isString(x) == false ) {
                        x=JSON.stringify(x) //w: for later comparison
                    }
                    self.data.runHARTaskMessages.push(x)
                }

                var newTask = c.tasks.createTask(taskSettings);
                return newTask
            }


            var newTask =  runHARDownloaderTask()


            return;

            //todo ... verify functioning.... that remove is recieving requests
            function sendUpdates() {

                function hasMessage(message, throwError) {
                    message = JSON.stringify(message);
                    if ( sh.includes(self.data.runHARTaskMessages,message)){
                        return true
                    }
                    if ( throwError != false ) {
                        throw new Error('did not receieve a message '+message)
                    }
                    return false;
                }

                sh.waitXSecs(3,function updateTask(){
                    var checkMsg = newTask.addUpdate({m:'he', type:"echo"})
                    sh.waitXSecs(10,function updateTask(){
                        hasMessage(checkMsg)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end')



                //verify messages are being sent
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    var checkMsg = newTask.addUpdate({type:"method",m:'he222', type:"echo"})

                    sh.waitXSecs(5,function updateTask(){
                        hasMessage(667, false)
                        hasMessage(checkMsg, false)
                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTaskCallMethodToEcho(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:['testMethoEcho']})
                    sh.waitXSecs(5,function verifyMessageReiceved(){
                        hasMessage(["testMethoEcho"])
                        ///>>>
                        restartTask()

                    }, 'check msg was sent')

                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            sendUpdates()



            function restartTask() {

                sh.waitXSecs(4,function restartHarTask(){
                    var task = self.s.tasks.utils.getTask('runHarProxy')
                    var task_id = task.id;
                    self.data.taskIDOrigHAR = task_id
                    self.proc('restarting server ...')
                    //w:old server will close, providing a lapse with no calllbacks
                    sh.waitXSecs(15,function provideLapseTimeForServerToCatchUp(){
                        self.proc('lapse over')
                        var task = self.s.tasks.utils.getTask({name:'runHarProxy',completed:false}, true)
                        var task_id = task.id;
                        if ( task_id == self.data.taskIDOrigHAR ) {
                            throw new Error('Tasks did not change')
                        }
                    } )

                    try {
                        runHARTask()
                    } catch (  e) {
                        self.proc('error', e)
                    }
                }, 'restart the har task')

                sh.waitXSecs(50,function verifyIdIsChanged(){
                    // self.s.tasks
                }, 'restart the har task...')
            }

            //restartTask()




            function startDownloadTask() {
                sh.wait1Sec(function updateTask(){
                    newTask.addUpdate({m:'he'})
                }, 'add update to task to send to remote end')
                sh.waitXSecs(3,function updateTask(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",m:'he222'})
                }, 'add update to task to send to remote end 3')

                sh.waitXSecs(4,function updateTask2(){
                    newTask.addUpdate({m:'he222'})
                    newTask.addUpdate({type:"method",
                        methodName:'testMeth', args:[5,6]})
                }, 'add update to task to send to remote end 3')

                c.syncContinually(1)
            }

            //  startDownloadTask()


        }


        p.basicTest = function basicTest(token, cb) {
            token.finished = false
            c.syncModel(step2);


            function step2(model) {
                c.model.hi = 'dddddd'
                c.model.emptyT = [5]
                c.syncModel(step3, true);
            }
            //step2();

            function step3(model) {
                c.model.hi = 'hhhhhhh'
                c.syncModel(step4, true);
            }

            function step4(model) {
                console.log('model', c.model)
                cb()
                token.finished = true
            }


        }
        p.verifyDontSendCommands = function verifyDontSendCommands(token, cb) {

            var UIOnlyTask = 'UIOnlyTask'


            var bail = false
            self.c.tasks.addTaskType(UIOnlyTask, self.VCommand2)
            var task = c.tasks.addTask(UIOnlyTask,
                '...desc',
                function fiveSecTaskDone(){
                    self.proc('UIOnlyTask', 'callback 5 sec task done')
                    if ( bail == true ){
                        return
                    }
                    cb()
                }
                , 'desc', self.c.settings.name)
            var result = c.syncModel(step2);
            if ( result != null ){
                // bail = true
                throw 'sent the file up....'
            }
            function step2(model) {
                //c.model.hi = 'dddddd'
                //  c.model.emptyT = [5]
                // c.syncModel(step3, true);
            }


        }
        var testerData = {}
        p.testCreatingTask = function testCreatingTask(token, cb) {

            function testCreatingTask(){
                var task = c.tasks.addTask(type.tasks.fiveSecTask,
                    'testCreatingTask',
                    function fiveSecTaskDone(){
                        console.log('callback 5 sec task done')
                        self.achievements.push('ran and tested a remote task')
                        cb()
                    }
                )
                testerData.fiveSecTaskId  =    task.id
                setTimeout(verifyTestCreatingTask, 5000)
                c.tasks.hasTask(testerData.fiveSecTaskId);
                //c.syncModel(verifyTestCreatingTask, true);
                c.syncContinually(1, verifyTestCreatingTask)
            }

            testCreatingTask();


            function verifyTestCreatingTask(model){
                return;
                if ( c.tasks.isTaskDone(testerData.fiveSecTaskId) ) {
                    console.log('task done....')
                } else {
                    console.log('task not done....')
                }
                c.model.hi = false
                //c.pullModel(step4, true);
            }
        }
    }
    defineWork()


    p.launch = function launch(x){
        var open = require('open');
        var url = 'http://localhost';
        url += ':'+self.settings.port;
        url += '/'+'InMemoryUIOnly2.htm'

        if ( self.settings.openUrl ) {
            open(url)
        }
        self.proc('open url to', url)
    }

    /**
     * Logging mixin
     */
    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }


}

exports.BolideLiteTest = BolideLiteTest;


if (module.parent == null) {
    var args = process.argv.splice(2);
    console.log('starting PNGProxy', args)

    var settings = {}
    var harProxy = new BolideLiteTest();
    //settings.openUrl = true
    //http://localhost:8001/InMemoryUIOnly2.htm
    harProxy.loadConfig(settings)
    return;
}