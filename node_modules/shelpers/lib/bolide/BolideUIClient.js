/**
 * Created by smorris1 on 1/3/14.
 */
var isBrowser = false
var isNode = true

if (typeof require !== 'undefined') {}
else {
    isBrowser = true
    isNode = false
}

if ( isNode ) {
    var sh = require('shelpers').shelpers;
    var SettingsHelper = require('shelpers').SettingsHelper;

    var request = require('request');
    var request = request.defaults({jar: true});

    //var EventEmitter = require('events').EventEmitter;


    var ExpressServerHelper = require('shelpers').ExpressServerHelper
    var TaskManager = require('./TaskManager').TaskManager
    var Actor = require('./ActorData').Actor
}

function BolideUIClient() {
    var p = BolideUIClient.prototype;
    p = this;
    var self = this;
    //self.notifier = new EventEmitter()
    //self.notifier.modelUpdated = function modelUpdated() {

    //}



    function defineLoadSettings() {
        p.loadSettings = function loadSettings(config){
            //load file and populate settings object
            //self.taskManager = new TaskManager();

            var defaultSettings = {}
            defaultSettings.allowedTasks = []
            defaultSettings.fxDetermineUserType
            defaultSettings.fxCanUserCreateTasks
            defaultSettings.fxCreateTask
            defaultSettings.timeoutTimeTasks = 60
            defaultSettings.maxTasksPerUser
            defaultSettings.name = 'client'
            defaultSettings.port = 7788

            defaultSettings.autoStart = true;


            //skip module parsing.
            //in browser, dev must use object only
            if ( isBrowser ) {
                var settings = {}
                settings = config;
                self.browserLoadSettings(settings, defaultSettings);
                return;
            }

            //load config
            var settingsHelperConfig = {}
            settingsHelperConfig.input = config;
            settingsHelperConfig.defaultSettings = defaultSettings;
            //settingsHelperConfig.arrayFields = ['skipRequests', 'skipRemotes']
            //settingsHelperConfig.objectFields = ['intercept/']

            //settingsHelperConfig.searchPaths = null;//
            settingsHelperConfig.fxResult = self.processSettings
            self.helper = SettingsHelper.LoadSettings(settingsHelperConfig);
            //JSON_Party_Save_Personal.har noChanges.json n1 PARTY westwest Test1234 1234 09174445

        }

        p.browserLoadSettings = function browserLoadSettings(settings, defaults) {
            //merge....
            settings= sh.mergeObjects(settings, defaults)
            self.processSettings(defaults)
            return;
        }

        p.processSettings = function processSettings(settings) {
            //handle preset modes
            //if ( mode == 'download' ) {
            //    settings.saveRequests = true;
            //}
            self.proc('options', settings)
            self.settings = settings;

            //go to original settings
            self.postProcessSettings(settings)
        }
        p.postProcessSettings = function postProcessSettings(settings) {
            //self.model.settings = defaultSettings;

            self.model = {}
            self.model.name = settings.name;
            self.model.id = new Date().getTime();
            self.model.revision_id = 0;
            self.model.revision_id_ui = 0;
            self.model.revision_id_remote = 0

            self.model.changesLog = {}


            self.model.tasks  = []; //ugh ...

            /*if ( self.settings.autoStart ) {
             self.startExpressServer();
             }*/
            defineTaskManager();
            sh.callIfDefined(self.fxStarted)
        }
    }
    defineLoadSettings();

    function defineSyncHelpers()  {
        self.surpressModelUpdate = function surpressModelUpdate(){
            var fxUndo_removeModelForSend = self.tasks.utils.removeModelForSend()
            try {
                var modelJSON = JSON.stringify(self.model)
            } catch ( e ) {
                console.error(e.stack)
                throw e
            }
            fxUndo_removeModelForSend()
            //self.tasks.utils.replaceModelForSend()
            if ( modelJSON == self.lastModelJSON ) {
                //oldTAsks ///compare if tasks need to be sent ...
                //console.log('urpress model update')
                if (self.settings.debugSupression != false ) {
                    self.proc('surpressModelUpdate')
                }
                return true
            }

            return false;
        }

        /**
         * Get final verify of model updates
         * //feature: limit data sent to remote.
         * //filter out my tasks, that i generated
         * //? tasks that have not changed status since last sent (mark them dirty)
         * //
         */
        self.modelUpdates = function modelUpdates(){
            var model = self.model;
            //do not send my tasks i am working
            //do not send my private spaced

            var fxUndo_removeModelForSend =  self.tasks.utils.removeModelForSend()
            //var clone = sh.clone(self.model)
            var clone = self.actor.cleanModelForSend()
            self.actor.checkSendableModel(clone)
            //self.tasks.utils.replaceModelForSend()
            fxUndo_removeModelForSend()
            delete clone[Actor.PrivateData]






            return clone;
        }


        /**
         * Send model to remote
         * use push pull if socket not found ....
         */
        self.syncModel = function syncModel(fxDone){
            if ( self.settings.useSocketIO) {

            } else {
                /* if ( this.oldModel() == null ) {
                 this.
                 }*/
                return self.pushModel(fxDone);
            }

        }
        self.syncContinually = function syncContinually(time, fxDone){
            self.syncStop();
            self.syncModel(fxDone)
            self.syncIntervalID = setInterval(function syncModelX(){
                    self.syncModel(fxDone)
                },
                    time*1000)

        }
        self.syncStop = function syncStop(time, fxDone){
            self.proc('stoppping the sync on', self.settings.name)
            clearInterval(self.syncIntervalID)
        }


    }
    defineSyncHelpers()


    p.checkModel = function checkModel() {
        if ( self.model.data != null && self.model.data.length > 0  ) {
           self.proc('invalid model')
            return;
        }
        if ( self.model.actor != null && self.model.actor.length > 0  ) {
            self.proc('invalid model')
            return;
        }
    }

    function definePushModel() {
        p.pushModel = function pushModel(fxDone) {
            self.checkModel();
            var urlPush = '/pushModel'
            var url = 'http://localhost:'+self.settings.port + urlPush;
            if ( self.settings.relativeUrls ) {
                url =   urlPush;
            }

            self.model.revision_id_ui++;
            if ( self.surpressModelUpdate() ) {
                fxDone();
                return
            }
            var model =  self.modelUpdates()
            {}
            self.actor.checkSendableModel(model)
            //console.error('....', sh.toJSONString(model) )
            //var model = self.model;
            if ( isNode ) {
                self.pushModelNode(url, model, fxDone)
            } else {
                self.pushModelJquery(url, model, fxDone)
            }
            //or could wait for task
            self.tasks.utils.removeAllIncomingMessages(self.model.tasks)
            self.proc(self.name, JSON.stringify(model))
            return model; //for testing return model
        }

        p.pushModelNode = function pushModelNode(url, model, fxDone) {
            var options = {}
            options.url = url; //'http://localhost:'+self.settings.port;
            //options.url += '/pushModel'
            options.method = 'POST'

            //model.name = self.settings.name;
            options.form = model;
            request(options, onPushModelConfirmed)

            function onPushModelConfirmed(error, response, body) {
                self.checkModel();

                if ( response != null && response.statusCode == 404){
                    console.error('404', body)
                    return;
                }
                if(body == null){
                    //   return
                    console.error('body == null')
                }
                if ( error != null ) {
                    console.error(error)
                }
                try {
                    var body = JSON.parse(body)
                } catch ( e ) {
                    console.error(body)
                    throw e
                }
                self.pushModelConfirmed(body, fxDone)
                return;
            }
        }

        p.pushModelJquery = function pushModelJquery(url, model, fxDone) {
            $.ajax({
                type: "POST",
                url: url,
                data: model,
                success: onPushModelConfirmed,
                dataType: 'json'
            });
            function onPushModelConfirmed(  body) {
                var model_ = body//JSON.parse(body);
                self.pushModelConfirmed(model_, fxDone)
            }
        }

        self.pushModelConfirmed = function pushModelConfirmed(model, fxDone) {
            //
            self.checkModel();
            model.tasks = self.tasks.utils.copyInTasks( self.model.tasks, model.tasks)
            self.model = model;
            self.checkModel();
            //console.log(options.url, body)
            if (fxDone != null) {
                fxDone(self.model);
            }
            self.modelUpdated();
            return;
        }
    }
    definePushModel();

    function definePullModel() {
        p.pullModel = function pullModel(fxDone) {

            var options = {}
            options.url = 'http://localhost:'+self.settings.port;
            if ( self.settings.relativeUrls ) {
                options.url =   '';
            }
            options.url += '/pullModel'

            request(options, fxCallback)

            function fxCallback(error, response, body) {

                console.log(options.url, body)
                var model_ = JSON.parse(body);
                self.model = model_;
                if ( fxDone != null ) {
                    fxDone(model_)
                }
                //self.notifier.modelUpdated();
                return;

            }

        }


        p.pullModel = function pullModel(fxDone) {
            var url = 'http://localhost:'+self.settings.port + '/pullModel';
            if ( self.settings.relativeUrls ) {
                url =   '/pullModel';
            }
            if ( isNode ) {
                self.pullModelNode(url, fxDone)
            }
            else {
                self.pullModelJquery(url, fxDone)
            }
        }

        p.pullModelNode = function pullModelNode(url, fxDone) {
            var options = {}
            options.url = url; //'http://localhost:'+self.settings.port;
            options.method = 'GET'
            self.model.revision_id_ui++;
            request(options, onPullModelConfirmed)

            function onPullModelConfirmed(error, response, body) {
                var body = JSON.parse(body)
                self.pullModelConfirmed(body, fxDone)
                return;
            }
        }

        p.pullModelJquery = function pullModelJquery(url, fxDone) {
            $.ajax({
                type: "GET",
                url: url,
                success: onPullModelConfirmed,
                dataType: 'json'
            });
            function onPullModelConfirmed(  body) {
                var model_ = body//JSON.parse(body);
                self.pullModelConfirmed(model_, fxDone)
            }
        }

        self.pullModelConfirmed = function pullModelConfirmed(model, fxDone) {
            self.model = model;
            //console.log(options.url, body)
            if (fxDone != null) {
                fxDone(self.model);
            }
            //self.notifier.modelUpdated();
            self.modelUpdated();
            //TODO: call other update fx ... make it newModelREcieved
            return;
        }
    }
    definePullModel()


    function defineTaskManager(){
        self.tasks = new TaskManager();
        //self.tasks.name = 'client';
        self.tasks.actor = self;
        self.tasks.settings = self.settings

        self.actor = new Actor();
        self.actor.actor = self;
        self.actor.settings = self.settings
    }



    function defineModelUpdators() {
        /**
         * Invoked whem model is changed
         * @param model
         * @param fxDone
         */
        self.modelUpdated = function modelUpdated(model) {
            //console.log('processing task')
            var oldTasks = self.model.tasks;
            delete self.model['tasks']
            self.lastModelJSON = JSON.stringify(self.model)
            self.model.tasks =  oldTasks;
            var undoRemoveForSend = self.tasks.utils.removeModelForSend(oldTasks);
            self.lastTasks = sh.clone(oldTasks);
            undoRemoveForSend();
            self.tasks.processTasks();
        }
    }
    defineModelUpdators();

    p.method1 = function method1(url, appCode) {
    }

    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }


}


if (isNode) {
    if (module.parent == null) {
        //do quick test ...
        var c = new BolideUIClient();
        var t = {}
        t.pushAfterTasks = false
        c.loadSettings(t)
        c.model = {}
        c.model.tasks = [];
        //self.model.tasks = [];
        //c.tasks.settings.allow = 'testTask'
        c.tasks.addTaskType('testTask')
        c.tasks.addTask('testTask', 666, function doneWithTask(result, success){
            console.log('.. completed task')
        }, 3000, true)
        c.tasks.processTasks()

        function VCommand() {
            var p = VCommand.prototype;
            var p = this;
            var self = this;

            self.name = 'some random command'
            self.settings = {}

            p.execute = function execute() {
                //self.data
                //self.success();
                setTimeout(function x () {
                    self.ok('555');
                }, 5000)

                return;
            }
        }
        c.tasks.addTaskType('testTask2', VCommand)
        c.tasks.addTask('testTask2', 777, function doneWithTask(result, success){
            console.log('.. completed task2')
        }, 3000, true)


        var Server = require('./BolideServer').BolideServer;
        var s = new Server();
        var serverConfig = {}
        serverConfig.autoStart = false;
        s.loadSettings(serverConfig);

        function VCommand2() {
            var p = VCommand.prototype;
            var p = this;
            var self = this;

            self.name = 'some random command'
            self.settings = {}

            p.execute = function execute() {
                //self.data
                //self.success();
                setTimeout(function x () {
                    self.ok('555');
                    c.model= s.model;
                    c.modelUpdated();
                }, 5000)

                return;
            }
        }
        //create remote tasks
        s.tasks.addTaskType('testTask3', VCommand2)
        //client make tasks
        c.tasks.addTask('testTask3', 777, function doneWithTask(result, success){
            console.log('.. completed task3')
        }, 3000, true)

        s.model= c.model;
        s.updatedModel();

        //c.model= s.model;
        //c.updatedModel();

    }
    exports.BolideUIClient = BolideUIClient;

}