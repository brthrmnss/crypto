/**
 * Created by user1 on 4/27/14.
 * Makes servers 'rebootable' hot-swappable
 * will send request to kill another server
 */
var sh = require('shelpers').shelpers
var properties = require('properties')
var fs = require('fs')
var request = require('request')

function BolideLite() {
    var p = BolideLite.prototype
    var self = this;
    self.data = {}
    self.data.updates= []

    p.proc = function proc(options ){
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }

    p.loadSettings = function loadSettings(settings) {
        self.settings = settings;

        var defaultSettings = {}
        defaultSettings.name = 'HARProxyServer'
        defaultSettings.file = "../../../../proxy/verifications/har_proxyserver.js"
        defaultSettings.obj = 'HARProxyServer'

        self.setup();
    }

    p.addUpdate = function addUpdate(update) {
        self.data.updates.push(update)
    }

    p.runTask = function  taskRun(req, res) {
        try {
            var pathToScript = __dirname + '/'+self.settings.file
            //check for abs path
            //just in case dev has relative load paths
            var scriptDir = sh.dirname(pathToScript)
            process.chdir(scriptDir);

            var scriptClazz = require('./'+self.settings.file)[self.settings.obj]
            var instance = new scriptClazz()

            var taskSettings = req.body.task
            self.addUpdate('echo STARTED CMD'   )

            instance.fxEcho = self.addUpdate ;
            //instance['fxExit'] = self.ok ;

            var configData = req.body.input;
            instance.loadConfig(configData)
            self.data.instance = instance;

            process.chdir(__dirname);
        }   catch ( e ) {
            console.error(e.stack )
            console.error(e.error )
            res.end('error '+ e.stack);
            return
        }


        res.end('run');
    }

    p.sendUpdates = function sendUpdates(res) {
        var json = JSON.stringify(self.data.updates);
        self.data.updates = [];
        res.end(json);
    }

    p.setup = function setup() {
        var app = self.settings.app;
        var prePend = '/'   +self.settings.name
        app.post(prePend+'/'+'run', self.runTask)
        app.get(prePend+'/'+'run', self.runTask)
        app.get(prePend+'_/', self.runTask)
        self.proc(prePend+'_/')
        app.get(prePend+'/'+'stop', function taskStop(req, res) {
            self.proc('stop')
            res.end();
        })

        app.post(prePend+'/'+'method', function method(req, res) {
            var body = req.body;
            var fx = self.data.instance[body.method]
            if ( fx == null ) {
                throw new Error(body.method + ' not found ')
            }
            if ( body.async == false ) {
                res.end();
                return;
            }

            fx.apply( self.data.instance, body.args )
            self.proc('method')
            self.sendUpdates(res)

        })

        app.post(prePend+'/'+'send', function taskSend(req, res) {
            self.proc('header exit request', id, _self)
            if ( req.body.sync != true ){
                res.end(); //get the update later
            }

            var json = JSON.stringify(self.data.updates);
            self.data.updates = [];
            res.end(json);


        })

        app.get(prePend+'/'+'get', function taskGetUpdateds(req, res) {
            self.proc('taskGetUpdateds' )
            var json = JSON.stringify(self.data.updates);
            self.data.updates = [];
            res.end(json);
        })
    }

    /**
     * Will destroy the old server if found
     * @param fxCallback
     */
    p.exitExisting = function exitExisting(fxCallback, serverPortNumber) {
        var options = {}
        options.url = 'http://localhost:'+serverPortNumber+'/exit'
        self.proc('serverPortNumber', serverPortNumber);
        if ( sh.isNull(serverPortNumber)){
            throw 'need a valid port number'
        }
        options.timeout = 1500 //wait before assume previous instance does not exist
        request(options, function onExitResponse (error, response, body) {
            self.proc('...',serverPortNumber, error, body) //you will get errof if alreadyended
            sh.waitXSecs(1, function attemptToStartServer() {
                sh.callIfDefined(fxCallback)
            }, 'attemptToStartServer')

        })
    }

    p.startup = function startup(fxCallback, serverPortNumber) {
        p.exitExisting(fxCallback, serverPortNumber)
    }


}



exports.BolideLite = BolideLite

if (module.parent == null) {

}
