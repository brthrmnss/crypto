/**
 *
 *Wrapper on promise library for ease of use
 * @type {{}}
 */

var sh = require('shelpers').shelpers
var Q = require("q");

function PromiseHelperV2() {
    var self = this;
    var p = PromiseHelperV2.prototype;

    self.starter = "--\t\t"
    self.debugName = self.starter+'PromH'
    self.data = {}

    self.start = function start(arg1) {
        var deferred = Q.defer();
        console.log('starting...')
        console.log('starting/', arg1)
        deferred.resolve(arg1);
        deferred.promise.fail(function (error) {
            setTimeout( function wait500MsForLogToFlush() {
                self.proc("error occured: " + error, JSON.stringify(error))//, error.stack);
            }, 500)
            //console.error("error occured: " + error);
        })
        self.lastPromise = deferred.promise
        return deferred.promise;
    }

    /**
     * simplify chaining
     * @param arg1
     * @returns {PromiseHelperV2}
     */
    self.startChain = function startChain(token, userSettings) {
        self.processSettings(userSettings)
        self.token=token;
        self.start(token);
        return self;
    }


    /**
     * Mix in user settings.
     * @param userSettings
     * @returns {{}|*}
     */
    self.processSettings = function processSettings(userSettings) {

        self.defaultSettings = {}
        self.defaultSettings.addFailHandlerOnEnd = true
        self.defaultSettings.ignoreNull = true

        self.settings = self.defaultSettings;

        self.data = {}
        self.data.methods = {}
        self.data.methods.count = 0
        self.data.methods.currentIndex = 0

        return self.settings;
    }

    /**
     * Add method to work-chain
     * Method will be based 2 parameters,
     * token, and a callback
     * you must call the callback for the chain to proceed
     * @param fx
     * @returns {PromiseHelper}
     */
    self.add = function add(fx) {
        self.data.methods.count++
        self.lastPromise = self.lastPromise.then(self.w(fx))
        return self;
    }

    /**
     * Add unwrapped method.
     * This is syncrhonous, no callback is passed
     * @param fx
     * @returns {PromiseHelper}
     */
    self.addSync = function addSync(fx) {
        self.data.methods.count++
        //self.lastPromise = self.lastPromise.then(self.w(self.rawWrapper(fx)))
        self.lastPromise = self.lastPromise.then(self.w(
            function rawWrapper (token, callback) {
                fx()
                callback(token)
            }

        ))
        return self;
    }

    self.addRaw = self.addSync

    /**
     * Method indicates dev has completed adding methods to chain
     * @param fx
     * @returns {PromiseHelper}
     */
    self.end = function end(fx) {
        if ( self.settings.addFailHandlerOnEnd ) {
            self.lastPromise = self.lastPromise.fail(function (error) {
                self.proc("error occurred: " + error);
                console.error("error occurred: " + error);
                console.error("error occurred: " + error.stack);
            });
        }

        self.addRaw(function () {
            console.log('finished.................', self.token.name, self.data.methods.count)
        });
        self.proc('added ', self.data.methods.count)
        return self;
    }

    self.showProgress = function showProgress() {
        var percentage  =  (self.data.methods.currentIndex/self.data.methods.count)
        percentage *= 100
        percentage = percentage.toFixed(2)
        percentage += '%'
        console.log(self.debugName, percentage)
        return
        self.proc('%',
            (percentage).toFixed(2), '%', self.data.methods.currentIndex, self.data.methods.count)
        return self;
    }



//    self.rawWrapper = function rawWrapper (token, callback) {
//        callback()
//    }

    self.fail = function fail(fx) {
        self.lastPromise = self.lastPromise.fail(fx)
        return self;
    }

    self.log = function log(arg1) {
        var deferred = Q.defer();
        //action(arg1, arg2, deferred.resolve);
        console.log('done...')
        console.log('log/', arg1)
        deferred.resolve(arg1);
        return deferred.promise;
    }

    self.log = function log(arg1) {
        self.lastPromise = self.lastPromise.then(self.w(function showToken(token, cb) {
            self.proc('log2', sh.toJSONString( self.token) )
            cb();
        }))
        return self;
    }

    self.showToken = self.log

//    self.wrapMethod = function wrapMethod(fx) {
//        var wrapperFx = function autoGenWrapper(opts) {
//            var deferred = Q.defer();
//            fx(opts, deferred.resolve);
//            return deferred.promise;
//        }
//        return wrapperFx;
//    }

    self.wrapMethod = function wrapMethod(fx) {
        //this is for prototyping, devs may apply method placeholder
        //that do not exist
        if ( fx == null && self.defaultSettings.ignoreNull == true ) {
            return self.lastPromise;
        }
        var wrapperFx = function autoGenWrapper(token) {
            var deferred = Q.defer();
            function temp(token, resolve) {
                //console.log('-->', fx) //auto trace name
                //console.log('----------->')
                console.log()
                self.showProgress()
                self.data.methods.currentIndex++
                console.log(self.debugName, 'next method', fx.name)
                console.log()

                if ( token == null ) {
                    //we used to show warnings
                    //we have added token to self so if
                    //user forgets to pass it to callback,
                    // we will fix it ...
                    if ( self.settings.showNullTokenWarnings ) {
                        self.proc('token is null')
                    }
                    token = self.token;
                }
                fx(token, deferred.resolve);
            }
            function fxDone() {
                deferred.resolve(token) //auto commit token, and log
            }
            temp(token, fxDone);
            return deferred.promise;
        }
        return wrapperFx;
    }

    self.w = self.wrapMethod;

    //predefined helper methods to simpslify chain config
    self.utils = {}
    self.utils.wait10Secs = function wait10Secs(token, callback) {
        if ( self.wait == false){
            callback(token)
            return
        }

        setTimeout( function wait10() {
            callback(token)
        }, 10*1000)

        var count = 10;
        var totalTime = 10000
        for ( var i = 0; i < count; i++ ) {
            var time = i*1000
            setTimeout( function tellTime(time) {
                console.log((totalTime-time)+'...')
            }, time, time )
        }

    }

    self.utils.wait3Secs = function wait3Secs(token, callback) {
        setTimeout( function wait3() {
            callback(token)
        }, 3*1000)
    }



    self.demo  = {}
    self.demo.exampleUsage = function exampleUsage() {
        log(data)
            /*
             .then(pb.searchForTorrent)
             .then(log)
             .then(pb.getFirstQueryResult)
             .then(log)
             .then(pb.convertMagnetLinkToTorrent)
             .then(log)
             */
            //cleanup existing files beforehand(or after)
            .then(wrapMethod(pb.putIORemoveFiles))
            .then(log)
    }



    self.demo.exampleInnerFx = function exampleInnerFx(opts, callback) {
        callback(opts)
    }


    p.proc = function proc() {
        sh.sLog(arguments)
    }


}

//exports.PromiseHelperV2 = PromiseHelperV2;
exports.PromiseHelperV2 = PromiseHelperV2;

if ( module.parent == null ) {



}