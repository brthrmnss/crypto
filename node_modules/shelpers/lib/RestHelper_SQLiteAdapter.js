var shelpers = require('shelpers')
var sh = shelpers.shelpers;
var PromiseHelperV3 = shelpers.PromiseHelperV3;
var express = require('express'),
    expressRest = require('express-rest');
var GenerateData = shelpers.GenerateData;
var  test = {}

var RestHelper = shelpers.RestHelper;
var Sequelize = require('sequelize')
var sequelize = null;


function SQLiteAdapater(settings) {
    var self = this;
    var p = this;
    if ( settings == null ) {
        throw new Error('need settings');
    }

    self.settings = settings;

    self.dbg = {};
    //self.dbg.breakOnAdd = true;
//asdf.g
    var cfg = {}
    cfg.db = {}
    cfg.db.database = 'fileserver';
    cfg.db.user = 'root';
    cfg.db.password = 'password';
    cfg.db.port = '3306';
    if ( settings.cfg ) {
        cfg = settings.cfg;
//        asdf.g
    }


    if ( self.settings.settings != null &&
        self.settings.settings.logging == false ) {
    self.settings.logging = false
    }
    if ( self.settings.logging === false  ) {
        cfg.db.logging = self.settings.logging
    }

    //sh.exit('logging', self.settings.logging)
    self.name = settings.name;



    var sequelize = new Sequelize(cfg.db.database, cfg.db.user, cfg.db.password, {
        dialect: "sqlite", // or 'sqlite', 'postgres', 'mariadb'
        port:    cfg.db.port, // or 5432 (for postgres)
        define: {
            timestamps: true//,
        },
        logging:cfg.db.logging
    })
    self.sequelize = sequelize

    self.defineUtils = function defineUtils() {


        p.utils = {};


        p.utils.upgradeTableFxs = function upgradeTableFxs(table) {
            //check if proper version 
            var fxFindAll = table.findAll
            table.findAll = function findAllRedirect() {
                var args = sh.convertArgumentsToArray(arguments)
                var result = fxFindAll.apply(this, args)

                result.success = function redirectSuccess(fx) {
                    result.then(fx);
                }

                result.fault = function redirectFault(fx) {
                    result.catch(fx);
                }

                result.catch(function globalCatch(err) {
                    console.error('something happend too', err)
                })

                return result;
            }



            var fxCount = table.count
            table.count = function countRedirect() {
                var args = sh.convertArgumentsToArray(arguments)
                var result = fxCount.apply(this, args)

                result.success = function redirectSuccess(fx) {
                    result.then(fx);
                }

                result.fault = function redirectFault(fx) {
                    result.catch(fx);
                }

                result.catch(function globalCatch(err) {
                    console.error('something happend too', err)
                })

                return result;
            }


        }

        self.utilsTest = {};
        self.utils.createIt = function createIt(props){
            console.log(props.msg)
            var user = props.model.build(props.props)

            user.save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                        props.callbackRetry(props.token, props.callback)
                    }
                })

            return
        }

        self.utils.getItemIfNotDefinedRetry = function getItemIfNotDefinedRetry(props){
            props.query = sh.defaultValue(props.query, {});
            var itemName = props.model.name.toString();

            props.model.findAll(props.query).success(function(resultObj) {

                //console.log('...')

                if ( resultObj == null ) {

                    self.utils.createIt(props)


                    return
                }

                props.storeItem = sh.dv(props.storeItem, itemName)
                props.token[props.storeItem] //.user= user;
                props.callback()
            })


        }


        self.utils.search = function search(props) {
            props.query = sh.defaultValue(props.query, {});
            var itemName = props.model.name.toString();

            if ( props.limit != null ) {
                props.query.limit = props.limit;

            }
            if ( props.offset != null ) {
                props.query.offset = props.offset;
            }

            props.query.limit = sh.dv(props.query.limit, 10);
            if (props.query.where == null ) {
                var query = {}
                query.where = props.query;
                if ( props.query.limit != null ) {
                    query.limit = props.query.limit
                    delete  props.query.limit
                }
                if ( props.query.offset != null ) {
                    query.offset = props.query.offset
                    delete  props.query.offset
                }
                if ( props.query.query != null ) {
                    // var y = {}
                    var cleanedQuery = []
                    var cleanQuery = true


                    var query2 = {}
                    var andQuery = []
                    if ( props.userId != null ) {
                        andQuery.push({user_id: props.userId});
                    }
                    sh.each(props.query.query, function f(k,v) {
                        if ( k == 'limit') {
                            return;
                        }
                        if ( k == 'offset') {
                            return;
                        }
                        if ( k == 'fxResult' ) {
                            return;
                        }
                        query[k]= {};

                        var querySet = {}
                        querySet[k] = {like: "%" + v + "%"}
                        //andQuery.push({ src: {like: "%" + query.season_name + "%"} })

                        andQuery.push(querySet);

                        if ( sh.includes2(v, 'like ?')) {
                            cleanQuery = false
                        }
                    })

                    var arr =  Sequelize.and.apply(this, andQuery)

                    /*
                     sh.each(props.query.query, function f(k,v) {
                     // y.u = 'l';
                     //cleanedQuery.push( [k + ' LIKE ?', '%'+v+'%' ])

                     if ( k == 'limit') {
                     return;
                     }
                     if ( k == 'offset') {
                     return;
                     }
                     sh.tick = function surroundWithBackticks(x) {
                     return '`'+x+'`';
                     }
                     cleanedQuery.push(  sh.tick(self.settings.name)+'.'+k + ' LIKE ?'  )
                     cleanedQuery.push(   '%'+v+'%'  )
                     if ( v != null ) {
                     return;
                     }
                     if ( sh.includes2(v, 'like ?')) {
                     cleanQuery = false
                     }
                     })
                     */
                    query.where = props.query.query;
                    if ( cleanQuery ) {
                        query.where = cleanedQuery//.join(' ');
                        query.where = arr;
                    }
                }
                props.query = query;

            }
            props.callback = sh.dv(props.callback, props.cb);


            var dbAction = props.model.findAll;

            if ( props.countOnly == true ) {
                dbAction = props.model.count
            }

            //make this the model
            // dbAction.call(props.model,props.query).

            if (props.countOnly!= true) {
                props.model.findAll(props.query).success(function(resultObj) {

                    //console.log('...')

                    if ( resultObj == null ) {

                        // self.utils.createIt(props)


                        return
                    }

                    //props.storeItem = sh.dv(props.storeItem, itemName)
                    //props.token[props.storeItem] //.user= user;
                    props.callback(resultObj)
                })
            } else
            {
                props.model.count(props.query).success(function(resultObj) {

                    //console.log('...')

                    if ( resultObj == null ) {

                        // self.utils.createIt(props)


                        return
                    }

                    //props.storeItem = sh.dv(props.storeItem, itemName)
                    //props.token[props.storeItem] //.user= user;
                    props.callback(resultObj)
                })
            }



        }
    }
    self.defineUtils();



    function defineWork() {
        /**
         * Create the table definition from the settings 'field' object
         * @param token
         * @param cb
         */
        p.defineTable = function defineTable(token, cb) {
            var tableFields  = {}
            if ( self.settings.settings ) {
                var tableOptions = sh.dv(self.settings.settings.tableOptions, {});
            } else {
                var tableOptions = sh.dv(self.settings.tableOptions, {});
            }

            if (  tableOptions.timestamps == null )
                tableOptions.timestamps=true;


            var DataTypes = Sequelize;
            tableFields=  {
                id:{ type: DataTypes.INTEGER(10),
                    allowNull: false,
                    primaryKey:true,
                    autoIncrement:true}
            }

            sh.each( token.settings.createFields, function addField(k,v ) {

                //blank
                if ( v == null || v === "" ) {
                    tableFields[k] = {
                        type: DataTypes.STRING
                        // allowNull: false,
                    }
                    return;
                }
                if (  v == "text" ) {
                    tableFields[k] = {
                        type: DataTypes.TEXT()
                        // allowNull: false,
                    }
                    return;
                }
                if ( v == true ) {
                    tableFields[k] = {
                        type: DataTypes.BOOLEAN
                    }
                    return;
                }
                if ( v == "date" || v.getTime != null ) {
                    tableFields[k] = {
                        type: DataTypes.DATE
                    }
                    return;
                }
                if (v.hasOwnProperty('_typeName')) {
                    tableFields[k] = v
                } else {
                    if (v.type == 0 || v == 0  ) {
                        v = {
                            type: DataTypes.INTEGER(10)
                        }
                        //v.type = DataTypes.INTEGER(10);
                    }
                    if ( v.type == true  ) {
                        v = {
                            type: DataTypes.BOOLEAN()
                        }
                    }
                    tableFields[k] = v
                }
            })
            /*

             name: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             fileName: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             path: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             category: {
             type: DataTypes.STRING,
             allowNull: true,
             },
             type: {
             type: DataTypes.STRING,
             allowNull: false,
             },
             */
            /*updatedDate: {
             type: DataTypes.DATE,
             allowNull: false,
             defaultValue: 'CURRENT_TIMESTAMP'
             },*//*

             isDeleted: {
             type: DataTypes.BOOLEAN,
             allowNull: true,
             defaultValue: '0'
             }
             */

            var Table =  null;
            function newTableDefinition (sequelize, DataTypes) {
                console.error(tableOptions)
                return sequelize.define(token.settings.name, tableFields, tableOptions)
            };

            Table = newTableDefinition(sequelize,Sequelize);

            self.Table = Table;
            cb();
            return;
        }
        p.connectToDb = function connectToDb(token, cb) {
            sequelize
                .authenticate()
                .then(function(err) {
                    if (!!err) {
                        console.log('Unable to connect to the database:', err, err.stack)
                    } else {
                        console.log('Syced successfully.')
                        cb();
                    }
                })

        }
        p.syncDatabaseDefintion = function syncDatabaseDefintion(token, cb) {
            sequelize.sync({force: true}).then(function (err) {
                if (!!err) {
                    console.log('Unable to sync the database:', err, err.stack)
                } else {
                    console.log('Connection has been established successfully.')
                    cb();
                }
            });
            return;


        }

        p.getUser = function getUser(token, cb) {
            self.utils.getItemIfNotDefinedRetry(
                {
                    model:User,
                    props:{
                        username: 'user1',
                        password: "password",
                        email: "user@user.com",
                        token: "234234"
                        //  password: generatePasswordHash('i-am-so-great')
                    },
                    msg:'User does not exists...',
                    callback:cb,
                    token:token,
                    callbackRetry:self.getUser
                }

            )


            return;
            User.find({}).success(function(user) {

                // project will be an instance of Project and stores the content of the table entry
                // with id 123. if such an entry is not defined you will get null
                console.log('...')

                if ( user == null ) {

                    self.utils.createIt(
                        {
                            model:User,
                            props:{
                                username: 'user1',
                                password: "password",
                                email: "user@user.com",
                                token: "234234"
                                //  password: generatePasswordHash('i-am-so-great')
                            },
                            msg:'User does not exists...',
                            callback:cb,
                            token:token,
                            callbackRetry:self.getUser
                        }
                    )

                    console.log('user was null...')
                    var user = User.build({
                        username: 'user1',
                        password: "password",
                        email: "user@user.com",
                        token: "234234"
                        //  password: generatePasswordHash('i-am-so-great')
                    })

                    user.save()
                        .complete(function(err) {
                            if (!!err) {
                                console.log('The instance has not been saved:', err)
                            } else {
                                console.log('We have a persisted instance now')
                                self.getUser(token, cb)
                            }
                        })

                    return
                }


                token.user= user;
                cb()
            })

        }
        p.getContent = function getContent(token, cb) {
            Content.find({}).success(function(content) {
                // project will be an instance of Project and stores the content of the table entry
                // with id 123. if such an entry is not defined you will get null
                console.log('...')
                if ( content == null ) {
                    console.log('content null...')
                    var content = Content.build({
                        name: 'Test Content',
                        fileName: "hhh.txt",
                        path :"D",
                        type: "type?"
                        //  password: generatePasswordHash('i-am-so-great')
                    })

                    content.save()
                        .complete(function(err) {
                            if (!!err) {
                                console.log('The instance has not been saved:', err)
                            } else {
                                console.log('We have a persisted instance now')
                                self.getContent(token, cb)
                            }
                        })

                    return
                }
                token.content= content;
                cb()
            })

        }
        p.createUserContent = function createUserContent(token, cb) {
            var userContent = UserContents.build({
                clientIP: 'john-doe',
                //  password: generatePasswordHash('i-am-so-great')
            })


            userContent.setContent(token.content)
            userContent.setUser(token.user)
            //sdfgdf.d
            cb();
            return
            userContent
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                    }
                })
        }

        p.createContent = function createContent(token, cb) {
            var newItem = self.Table.build({
                name: 'john-doe',
                //  password: generatePasswordHash('i-am-so-great')
            })


            if ( self.dbg.breakOnAdd ) {
                asdf.g
            }
            //userContent.setContent(token.content)
            //userContent.setUser(token.user)
            newItem
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        cb();
                        self.newItem = newItem;
                        token.id = newItem.dataValues.id;
                        console.log('We have a persisted instance now')
                    }
                })

            return
            userContent
                .save()
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        console.log('We have a persisted instance now')
                    }
                })
        }

        p.readContent = function readContent(token, cb) {
            self.utils.search({model:self.Table,
                    callback:function(results){
                        console.log('results', results.length);
                        if ( results.length != 1 ) {
                            throw new Error('ugggg')
                        }
                        cb();
                    }, query :{where:{id:1}}
                }
            )

        }

        p.updateContent = function updateContent(token, cb) {

            self.utils.local={}
            self.utils.local.search = function search(props) {
                self.utils.search({model: self.Table,
                        callback: function (results) {
                            console.log('results', results.length);
                            if (results.length != 1 &&  props.throwErrorIfEmpty==true) {
                                throw new Error('ugggg')
                            }
                            props.cb(results)
                        }, query: {where: props.query}
                    }
                )

            }

            var newName = 'newNAme6'

            self.utils.local.search( {
                    query:{id:1},
                    cb:doUpdate
                }
            )
            function doUpdate(results) {

                var result = results[0];
                result.updateAttributes({name:newName})
                    .complete(function(err) {
                        if (!!err) {
                            console.log('The instance has not been saved:', err)
                        } else {
                            console.log('doUpdate', 'We have a persisted instance now')
                            testNameUpdate()
                        }
                    })
                // cb();
            }



            function testNameUpdate() {
                self.utils.local.search( {
                        query:{id:1},
                        cb:testName
                    }
                )
                function testName(results) {
                    var result = results[0];
                    if ( result.dataValues.name != newName ) {
                        throw new Error('did not update the name ... to ' +newName)
                    }
                    cb();
                }

            }

        }

        p.deleteContent = function deleteContent(token, cb) {

            var newName = 'newNAme6'

            self.utils.local.search( {
                    query:{id:1},
                    cb:deleteItem
                }
            )
            function deleteItem(results) {
                var result = results[0];
                result.destroy().complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been destroyed:', err)
                    } else {
                        console.log('destroyed')
                        testDestroy();
                    }
                })

            }

            function testDestroy() {
                self.utils.local.search( {
                        query:{id:1},
                        cb:testDestroy_
                    }
                )
                function testDestroy_(results) {
                    var result = results[0];
                    if ( results.length != 0  ) {
                        throw new Error('did not destroy the item ');// the name ... to ' +newName)
                    }
                    cb();
                }

            }

        }




        p.listContent = function listContent(token, cb) {

            self.utils.search( {
                    model:self.Table,
                    query:{},
                    cb:list,
                    limit:10,
                }
            )
            function list(results) {
                var json = []
                sh.each(results, function addToResults(k,v){
                    json.push(v.values)
                });


                cb()
                return;

            }

        }



        self.bulkAdd = function bulkAdd(results, cb) {



            if ( self.dbg.breakOnAdd ) {
                sh.x('breakonadd', results)
                asdf.g


            }

            self.Table.bulkCreate(results).then(
                function(results) {
                    // Notice: There are no arguments here, as of right now you'll have to...
                    if ( cb != null ) cb(results);
                    return;
                    /*self.Table.findAll().then(function(users) {
                     //  console.log(users) // ... in order to get the array of user objects
                     })

                     self.Table.findAll({ where: ["name LIKE ?", "%1%"] }).then(function(users) {
                     console.log('h',users) // ... in order to get the array of user objects
                     })
                     return
                     self.Table.findAll({where:{name:{$like:'5'}}}).then(function(users) {
                     console.log('h',users) // ... in order to get the array of user objects
                     })*/
                }).catch(function (err) {
                console.log(err)
                // exit();
                setTimeout(function() {
                    throw err;
                },5)


            });
        }
    }
    defineWork()


    function defineAPI() {
        self.fxGet =  function getRecord(req, rest) {
            self.getId(req.params.id, function onGotRecord(record)
            {
                if (record) rest.ok(record);
                else rest.notFound();
            }, self.userId(req));

        };

        self.userId = function userId(req, fx) {
            if ( self.settings.fxUserId== null ) {
                return null;
            }
            var userId = self.settings.fxUserId(req)
            if ( fx != null && sh.isFunction(fx) ) {
                fx(userId);
                return userId
            }
            if ( fx != null && sh.isObject(fx) ) {
                fx.user_id = userId;
            }
            return userId
        }

        self.fxCreate =  function createRecord(req, rest, body ) {
            // self.userId(function(userId){body.user_id=userId})
            self.userId(req, body)


            if ( self.dbg.breakOnAdd ) {
                sh.x('breakonadd', results)
                asdf.g


            }
           // console.log('creating an item fxCreate createRecord', body)
            //sh.exit('why u here?')

            var user = self.Table.build(body)

            user.save().success(function(o) {

                //not in Rest HTTP Spec, but xhr ignores location header on
                //rest values
                rest.created('/api/'+self.name+'/' + o.dataValues.id,
                    o.dataValues.id);

            })
                .complete(function(err) {
                    if (!!err) {
                        var debugItem = body;
                        //asdf.ggggggg
                        self.proc('The instance has not been saved:', err)
                        console.error(err.stack)
                    } else {
                        if ( self.settings.settings != null &&
                            self.settings.settings.logging == false ) {
                            //self.proc('...')

                        }
                        else {
                            self.proc('We have a persisted instance now')
                        }
                        //   props.callbackRetry(props.token, props.callback)
                    }

                })

            return;
        };


        self.fxUpdate =  function updateRecord(req, rest, body ) {
            self.getId(
                body.id, function postUpdateAction(object) {
                    var to = object;
                    if ( to == null ) {
                        var msg =('could not find id ' + body.id)
                        console.error(msg)
                        //rest.statusCode = 404;
                        // rest.send(msg)
                        rest.notFound('Error: record does not exist' +
                            'Error: could not find id ' + body.id)
                        return;
                    }
                    self.utils.updateItem(body, to, function saved() {
                        return rest.accepted('/api/' + self.name + '/' + encodeURI(body.id) ,body.id);
                    })
                },self.userId(req));

        };


        self.fxDelete =  function fxDelete(req, rest, id ) {
            self.getId(
                id, function o(result) {
                    if ( result == null) {
                        //throw new Error ('not found')
                        rest.notFound('Error: record does not exist' +
                            'Error: could not find id ' + id)
                        return;
                    }
                    result.destroy().complete(function(err) {
                        if (!!err) {
                            console.log('The instance has not been destroyed:', err)
                        } else {
                            console.log('destroyed')
                            rest.gone();
                        }
                    })
                }, self.userId(req))

        };


        self.fxList = function fxList(req, rest, h) {
            //rest.ok(self.records);
            self.fxSearch(req, rest, h);
        }

        self.fxCount = function fxCount(req, rest, h) {
            if ( h == null ) { h= {};}
            self.fxSearch(req, rest, h);
        };

        self.fxSearch = function fxSearch(req, rest, h) {
            if (h.query == null ) {
                var query = {}
                var skipProps = ['limit']
                sh.each(h, function copyPropsToQuery(k,v){
                    if ( sh.includes(skipProps, k) ){
                        return;
                    }
                    query[k] = v;
                })

                h.query = {}
                h.query.query = query;

            }
            /*if ( req.userId != null ) {
             //asdf.g
             if (h.query == null ) {
             h.query = {}
             }
             h.query.user_id = req.userId;
             }*/
            //to ensure we can see req.session
            if ( req.session == null && req.req != null ) {
                req = req.req;
            }
            var countOnly = req.url.indexOf('/count') != -1
            self.utils.search( {
                    model:self.Table,
                    query: h.query,
                    cb:list,
                    limit: h.limit,
                    offset: h.offset,
                    userId:self.userId(req),
                    countOnly:countOnly
                }
            )

            function list(results) {
                if ( countOnly != true ) {
                    var json = []
                    sh.each(results, function addToResults(k, v) {
                        json.push(v.values);
                    });
                } else {
                    json = results; //the count
                }
                if (h.fxResult != null ) {
                    h.fxResult(results);
                    return;
                }
                rest.ok(json);
            }
        }


        self.cb = function blankCallback() {

        }

        self.resetDp = function resetDp(fxResetCallback) {
            var token = {};
            token.settings = {}//sh.clone(self.settings);
            token.settings.name = self.settings.name;
            token.settings.createFields = self.settings.fields;

            self.defineTable(token, self.cb);

            var opts = {}
            if ( self.settings.reset == true ) {
                opts = {force: true}
            }
            sequelize.sync(opts).then(function (results) {
                if (results.err != null ) {
                    console.log('Unable to sync the database:', err, err.stack)
                } else {
                    console.log('Connection has been established successfully.')



                    function addDataIfNeeded() {
                        self.Table.destroy({where:{}}).then(function() {
                            self.bulkAdd(self.settings.fxReset(), fxResetCallback);
                        })

                    };

                    if ( self.settings.reset == true ) {
                        addDataIfNeeded()
                    } else {
                        if ( self.settings.genData == RestHelper.types.GenDataIfEmpty ) {
                            self.utils.getLength(function isLength0(length){
                                if ( length == 0 ) {
                                    self.bulkAdd(self.settings.fxReset(), fxResetCallback);
                                } else {
                                    fxResetCallback();
                                }
                            })


                            return;
                        }
                        fxResetCallback();
                    }






                    // cb();
                }
            }).catch(function (err) {
                console.log(err)
                // exit();
                return;
                setTimeout(function() {
                    throw err;
                },3000)


            });
            return;


        }

        self.utils.getLength = function getLength(fxCallback) {

            self.Table.count({}).then(function(count) {
                fxCallback(count)
            })
            return;


        }


        self.utils.empty = function empty(fxCallback) {
            self.Table.destroy({where:{}}).success(function() {
                fxCallback()
            })
            return;


        }


        p.getId = function getId(id, cb, userId) {
            if (userId != null ) {
                id = {id:id}
                id.user_id = userId;
                id = {where:id};
            }
            self.Table.find(id).success(function(result) {
                cb(result)
            })
        }


        p.utils.updateItem = function updateItem(from, to, cb, silentNoDbg) {
           // console.log('s', silentNoDbg, self.settings.logging)
           // sh.exit()
            //asdf.g
            to.updateAttributes(from)
                .complete(function(err) {
                    if (!!err) {
                        console.log('The instance has not been saved:', err)
                    } else {
                        if ( self.settings.logging != false  && silentNoDbg != true )
                        console.log('updateItem', 'We have a persisted instance now')
                        sh.callIfDefined(cb)
                        //cb()
                    }
                })

        }



    }
    defineAPI();

    p.proc = function proc() {
        sh.sLog(arguments)
    }


}








exports.SQLiteAdapater  = SQLiteAdapater;


if ( module.parent == null ) {

}

