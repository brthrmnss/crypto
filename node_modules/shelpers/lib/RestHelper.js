var shelpers = require('shelpers')
var sh = shelpers.shelpers;
var PromiseHelperV3 = shelpers.PromiseHelperV3;
var express = require('express'),
    expressRest = require('express-rest');
var GenerateData = shelpers.GenerateData;
var  test = {}

function IdModelHelper() {
    var self = this;
    var p  = this;

    var types = {}
    types.GET = 'GET';
    types.POST = 'POST';


    self.settings = {} //global settings for model

    p.load = function load(settings) {
        var name = settings.name;
        self.name = name;
        self.settings = settings;

        settings.timestamps = sh.defaultValue(settings.timestamps, true);
        //settings.timestamps = sh.defaultValue(settings.timestamps, true);

        var rest = null;
        var app = null;
        if ( self.settings.server == null ) {
            var app = express();
            self.settings.server = app;
            rest = expressRest(app);
        } else {
            var app = self.settings.server;
            rest = expressRest(app);
        }

        if ( self.settings.doDefault == null) {
            self.settings.doDefault = true;
        }


        self.resetDp()

        if ( self.settings.dbg) {
            console.log('RestHelper', 'making model', name)
            console.log('RestHelper', rest.port, rest, '/api/' + self.name)
        }
        //list
        rest.get('/api/'+self.name+'', function listRecords(req, rest) {
            var output = self.getParamsAndData(req)
            var isPost = output.isPost;
            var params = output.params;
            var data = output.body;

            var query = req.query
            var limit = query.limit;

            var h = {};
            h.query = query;
            if ( self.settings.actor != null ) {
                self.settings.actor.fxList(req, rest, h);
                return;
            }

            rest.ok(self.records);
        });

        rest.get('/api/'+self.name+'/create', createItem);
        rest.get('/api/'+self.name+'/update', updateItem);
        rest.get('/api/'+self.name+'/delete', deleteItem);
        rest.get('/api/'+self.name+'/delete/:id', deleteItem);

        setTimeout(function defineWildCardRouteAfterPreviousRoutes () {
            //get
            rest.get('/api/'+self.name+'/:id',getRecord);
        }, 0)


        function getRecord(req, rest) {
            if ( self.settings.actor != null ) {
                self.settings.actor.fxGet(req, rest, req.params.id);
                return;
            }
            if ( self.settings.fxGet != null ) {
                self.settings.fxGet(req.params.id, rest.ok, req, rest)
                return;
            }

            var record = self.dict[req.params.id];
            if (record) rest.ok(record);
            else rest.notFound();
        };

        //update
        rest.put('/api/'+self.name+'/:id', updateItem);
        function updateItem(req, rest) {



            var params = req.params;
            var data = req.body;


            var output = self.getParamsAndData(req)
            var isPost = output.isPost;
            var params = output.params;
            var data = output.body;


            if ( self.settings.actor != null ) {
                self.settings.actor.fxUpdate(req, rest, data);
                return;
            }
            if ( self.settings.fxUpdate != null ) {
                self.settings.fxUpdate(req.params.id, rest.accepted, req, rest)
                return;
            }


            self.doesItemExist(data, true)

            var id = params.id;
            if ( id == null && output.isGet ) {
                id = req.query.id;
            }

            var foundItem = self.getId(id);
            /*
             sh.each ( self.records, function findItemById(i, item){
             if ( item.id == id) {
             foundItem = item;
             return false;
             }
             })
             */

            sh.each(data, function updateProps(k, v){
                foundItem[k]=v;
            })
            self.utils.updateTimestamps(foundItem);
            //sh.copyPropsFromTo(params, foundItem);
            //TODO: full replacement
            self.dict[id] = foundItem;

            self.updateRecords();

            return rest.accepted('/api/'+self.name+'/' + encodeURI(id));
        };

        //create
        rest.post('/api/'+self.name, createItem);
        rest.post('/api/'+self.name+'/create', createItem);
        function createItem (req, rest) {
            if ( self.settings.fxCreate != null ) {
                self.settings.fxCreate(req.params, rest.created, req, rest)
                return;
            }
            var path = '/api/' + self.name + '/';
            var output = self.getParamsAndData(req);
            var isPost = output.isPost; var isGet = output.isGet;
            var params = output.params;
            var body = output.body;

            //Mode 3, user specifies obj as ?obj=JSONSTRING
            self.doRequiredFieldCheck(body);

            var upsertQuery = body.upsertQuery
            if ( upsertQuery != null ) {

                var reqHelper  = {};
                reqHelper.fxResult = gotResult;
                reqHelper.query  = upsertQuery;
                reqHelper.req = req;

                self.searchItems(upsertQuery, null, null, reqHelper)
                function gotResult(results){
                    //perform upsert action
                    //var results = self.utils.find(upsertQuery)
                    var y = [upsertQuery]
                    if ( self.settings.logging != false  && req.silentNoDbg != true )
                    console.log('upsert-query>>>>>>', upsertQuery, results.length)
                    //asdf.g
                    if (results.length == 0) {
                        finishCreatingItem()
                        return;
                    }
                    //perhaps?
                    /*if (results.length != 1) {
                     return;
                     }*/
                    var updatedItem = results[0];
                    self.utils.updateItem(body, updatedItem, null, req.silentNoDbg);
                    //self.doNotSend = true;
                    rest.accepted(path + updatedItem.id);
                }
                return;
            }



            //had to self.createItem into to 2 methods, to support upsert .
            function finishCreatingItem() {


                delete body['upsertQuery']
                if ( self.settings.actor != null ) {
                    self.settings.actor.fxCreate(req, rest, body);
                    return;
                }

                self.doesItemExist(body)


                if (self.settings.createFx2 != null) {
                    var controller = {};
                    controller.helper = self;
                    controller.rest = rest;
                    controller.req = req;
                    controller.doNotSend = false;
                    controller.path = '/api/' + self.name + '/';
                    controller.item = body;
                    self.utils.updateTimestamps(body, true);
                    self.settings.createFx2(body, controller);
                    if (controller.doNotSend == true) {
                        self.updateRecords(); //ensure records are updated
                        return;
                    }
                }

                self.utils.updateTimestamps(body);
                self.addRecord(body);
                self.updateRecords();


                rest.created('/api/' + self.name + '/' + body.id);

                //rest.created('/api/'+self.name+'/' + (self.records.length - 1));
            }
            finishCreatingItem()
        }

        self.ext = {};
        self.ext.createItem = createItem;

        //delete
        function deleteItem (req, rest) {
            // delete self.records[req.params.id];

            var output = self.getParamsAndData(req)
            var isPost = output.isPost;
            var params = output.params;
            var data = output.body;

            //if get+delete/:id route , use id in route
            if (req.params.id != null ) { //&& is get
                params.id = req.params.id;
            }

            //so confusing, but get route is bizarre
            //this iswhen Get but object is used (which is wasteful)
            if ( params.id == null &&
                output.isGet && req.query.id != null ) {
                params.id = req.query.id;
            }

            if ( self.settings.actor != null ) {
                self.settings.actor.fxDelete(req, rest, params.id);
                return;
            }

            self.throwErrorIfItemDoesNotExist(params);
            var id = params.id;

            var foundItem = self.getId(id);

            if ( self.settings.fxDelete != null ) {
                self.settings.fxDelete(req, rest,req.params.id);
                return;
            }

            self.removeItem(params);

            rest.gone();
        }
        rest.delete('/api/'+self.name+'/:id', deleteItem)




        rest.get('/api/'+self.name+'/search', searchItems);
        self.searchItems = searchItems;
        function searchItems (req, rest, fxResult, settings) {

            if ( settings == null ) {
                if (fxResult == null) {

                    var output = self.getParamsAndData(req)
                    var isPost = output.isPost;
                    var params = output.params;
                    var data = output.body;

                    var query = req.query
                    var limit = query.limit;
                } else {
                    query = req;
                }
            }
            else
            {
                //could this be better?
                fxResult = settings.fxResult;
                query = settings.query;
                req = settings;
            }
            //gather all properties


            var h = {};
            h.query = query;
            if ( req.query && req.query.query != null ) {
                h = req.query; //why: fully query
            }
            if ( h.query && sh.isArray(h.query) && sh.isString(h.query[0] ) ) {
                //why: flat array of strings, ... nest for easy parsting
                h.query = [h.query]
                self.proc('encapuslated query in []', h.query)
            }
            //preserve query if where is present
            if (  query.where != null ) {
                h = {};
                h.query = req.query;
            }

            h.limit = limit;
            if ( req.query) {
                if (req.query.limit) {
                    h.limit = req.query.limit;
                }
                if (req.query.offset) {
                    h.offset = req.query.offset;
                    h.offsetCount = 0; //track offset count til add to set
                }
            }

            if (h.query == '{}' ) {
                h.query = {};
            }
            //h.query = query;h.limit = limit;
            h.fxResult = fxResult;

            if ( self.settings.actor != null ) {
                self.settings.actor.fxSearch(req, rest, h);
                return;
            }

            function returnResults(matches) {
                if ( fxResult != null ){
                    fxResult(matches)
                    return;
                }
                rest.ok(matches);
            }

            var matches = []

            var records = self.records;
           /* if ( self.settings.timestamps == true  ) {
                sh.sortBy(records, 'updatedAt')
                //asdf.g
            }*/

            console.error('1', sh.each.prop(records, 'id').join(' ') )
            sh.sortBy(records, 'updatedAt', function convertDateIfNotDate( x ) {

                var date = 0
                if ( sh.isString(x )) {
                    x = new Date(x)
                }
                return date;

            })
            console.error('2',sh.each.prop(records, 'id').join(' ') )

            function canAddItem() {
                if (h.offset) {
                    h.offsetCount++
                    if ( h.offsetCount <=  h.offset ) {
                        return false
                    }
                }
                return true;
            }

            var skipQueryProps = ['limit'];

            console.log('2nd record', records[1])
            //reverse so we can see the opposite
            sh.each(records, function checkForField(k,item){
                if ( h.limit != null ) {
                    if ( matches.length >= h.limit ) {
                        return false;
                    }
                }
                if ( h.query != null ) {
                    if (  sh.isString(h.query) ) {
                        if (sh.includes(item.name, h.query, true)) {
                            if ( canAddItem() )
                            matches.push(item);
                        }
                        return;
                    }
                    query = h.query;
                }

                //query = query.query;

                if ( sh.isEmptyObject(h.query) ) {
                    if ( canAddItem() )
                        matches.push(item);
                    return; //why: skip let blank object run no filters
                }

                var includeObject = false;
                var excludeObject = false;
                var skipNextIteration = false //like op spans 2 items in query array
                sh.each(h.query, function matchVAl(k,v){
                    //like query
                    if ( skipNextIteration == true ) {
                        skipNextIteration = false;
                        return;
                    }
                    if (sh.includes(skipQueryProps, k) ) { return }
                    /*if (  sh.includes(item[k], v , true) ) {
                     console.error('what...', h.query)
                     asdf.g //not sure if want to support this mode
                     includeObject = true
                     // matches.push(item); //debug??
                     return;
                     }*/
                    if ( k ==  'name LIKE ?') {
                        asdf.g.d.g
                    }
                    if ( sh.isArray(v)) {
                        var op = v[0]
                        var comp = v[1]
                        if (op.indexOf(' LIKE ') != -1) {
                            var prop = op.split(' LIKE ')[0]
                            skipNextIteration = true
                            var matchVal = comp; //query[k + 1]
                            matchVal = matchVal.toLowerCase()
                            matchVal = sh.replace(matchVal, '%', '')
                            var value = item[prop];

                            value = value.toString();
                            value = value.toLowerCase()
                            if (value.indexOf(matchVal) != -1)
                                return;

                            excludeObject = true
                            return false; //remove for x?
                        }
                    }

                    //why:basic mode prop and value
                    if (  true ) {
                        // skipNextIteration = true
                        var matchVal = v; //query[k + 1]
                        // matchVal = matchVal.toLowerCase()
                        var prop = k
                        var value = item[prop];

                        if ( value == null ) {
                            value = ''
                        }

                        value = value.toString();
                        //value = value.toLowerCase()
                        /* if (value.indexOf(matchVal) != -1)
                         return;
                         */
                        if (value == matchVal )
                            return;
                        excludeObject = true
                        return false; //remove for x?
                    }
                    //return false;
                })

                if ( /*includeObject &&*/ excludeObject == false ) {
                   if ( canAddItem() )
                    matches.push(item);
                }


            })



            console.log('query>>>>>>', h.query, matches.length)
            returnResults(matches)

        }
        self.ext.searchItems = searchItems;

        rest.get('/api/'+self.name+'/count', countItems);
        self.countItems = countItems;
        function countItems (req, rest, fxResult, settings) {
            if ( self.settings.actor != null &&
                self.settings.actor.fxCount != null ) {
                self.settings.actor.fxCount(req, rest);
                return;
            }
            self.utils.getLength(function (length) {
                length = length.toString();
                rest.ok(length);
            })
        }

    }

    function defineSearchHelpers() {
        /**
         * Redirects to searchItems
         * @param searchSettings
         */
        self.search = function search(searchSettings) {
            /*
             var reqHelper  = {};
             reqHelper.fxResult = gotResult;
             reqHelper.query  = upsertQuery;

             self.searchItems(upsertQuery, null, null, reqHelper)
             function gotResult(results){
             //perform upsert action
             //var results = self.utils.find(upsertQuery)
             if (results.length == 0) {
             finishCreatingItem()
             return;
             }
             //perhaps?

             var updatedItem = results[0];
             self.utils.updateItem(body, updatedItem);
             //self.doNotSend = true;
             rest.accepted(path + updatedItem.id);
             }
             */
            self.searchItems(null, null, null, searchSettings)
        }
    }
    defineSearchHelpers()

    p.loadRest = p.load;

    p.doesItemExist = function doesItemExist(item, reverse) {
        var id = parseInt(item.id)
        if ( item.id == null ) {
            if  ( reverse ) {
                throw new Error('record does not exist ' + sh.toJSONString(item));
            }
            return; //this is new
        }
        var doesNotExist = self.dict[id] == null;
        var exists = self.dict[id] != null;
        if  ( reverse ) {
            if ( doesNotExist ) {
                throw new Error('record does not exist ' + sh.toJSONString(item));
            }
            return;
        }
        if ( exists ) {
            throw new Error('record exists ' + sh.toJSONString(item));
        }
    }

    p.throwErrorIfItemDoesNotExist = function throwErrorIfItemDoesNotExist(item) {
        self.doesItemExist(item, true)
    }

    p.removeItem = function removeItem(idOrObjWithId) {
        var id = idOrObjWithId
        if ( idOrObjWithId.id != null ) {
            id = idOrObjWithId.id;
        }
        id = parseInt(id);
        for ( var i = 0 ; i < self.records.length; i++) {
            var r = self.records[i];
            if ( parseInt(r.id) == id ) {
                self.records.splice(i, 1);
                break;
            }
        }

        delete self.dict[id];
    }


    p.addRecord = function addRecord(item) {
        self.doRequiredFieldCheck(item)
        self.nextId++
        item.id = self.nextId
        self.records.push(item);
        self.dict[item.id] = item;
    }



    p.doRequiredFieldCheck = function doRequiredFieldCheck(item) {
        //TODO: use GenerateData.js
        if ( self.settings.requiredFields != null ) {
            sh.each(self.settings.requiredFields, function checkForField(k,v){
                if ( item[k] == null ) {
                    console.error('required field missing '+k)

                    throw new Error('required field missing '+k);
                }
            })
        }
    }

    p.updateRecords = function updateRecords() {
        sh.writeFile(self.settings.file,
            sh.toJSONString(self.records));
    }


    /**
     * Get param data from get or post calls
     * body is the query
     * params are the params from url task/:id
     * query is the query
     * issue was get does not have a body, this fixes that
     * @param req
     * @returns {{params: (*|params|exports.companyStartup.RemoteObjectRequest.params|exports.reportCenterStartup.params|parsed.params|obj.params), data: *, isPost: boolean, isGet: *}}
     */
    p.getParamsAndData = function getParamsAndData(req) {
        var isPost = req.method == types.POST;
        var isGet = req.method == types.GET;

        var params = req.params;
        var data = req.body;

        if ( isPost == false ) {
            params = req.params;
            data = req.body;
        }

        if (isGet) {
            data = req.query;//????
            if ( data.obj != null ) {
                data = JSON.parse(data.obj);
            }
        }

        return {params:params, data:data, body:data,
            isPost:isPost, isGet:isGet}

    }


    p.getId = function getId(id, cb) {
        if ( self.settings.actor != null ) {
            self.settings.actor.getId(id, cb);

            return;
        }


        var foundItem = null;
        sh.each ( self.records, function findItemById(i, item){
            if ( item.id == id) {
                foundItem = item;
                return false;
            }
        })
        /*if ( self.settings.actLikeSequlize != false && foundItem != null ) {
            foundItem.dataValues = sh.clone(foundItem);
        }*/

        if ( cb != null )  { cb(foundItem) }
        return foundItem;
    }


    /**
     * Setup self.records
     * @fxResetCallback - callback for when records are added
     */
    p.resetDp = function resetDp(fxResetCallback) {


        if ( self.settings.actor != null ) {
            self.busy = true

            self.settings.actor.resetDp(fxFinished);

            function fxFinished() {
                self.busy = false
                if ( fxResetCallback != null ) {
                    fxResetCallback()
                }
                if  ( self.settings.fxStart != null  ) {
                    self.proc('finished initializng', self.settings.name)
                    setTimeout(function startOutsideOfPromise() {
                        self.settings.fxStart();
                        self.settings.fxStart = null;
                    }, 50);


                }
            }

            return;
        }


        if  ( self.settings.model == null ) {
            //if ( sh.fileExists() self.settings.file == ) {
            //self.settings.model = JSON.parse(sh.readFile(self.settings.file,"[]"))
            self.records = []//self.settings.model.concat();;
            // }
        } else {
            self.records = self.settings.model.concat();;
        }

        var doDefault = false;



        var fileExists = false;
        var fileExists = sh.fileExists(self.settings.file);

        if ( self.settings.file != null    ) {


            if ( self.settings.fileUseAltFileForSafety ) {
                var origFile = self.settings.file;
                self.settings.file = self.settings.file+'.2.json'
                var fileAltExists = sh.fileExists(self.settings.file);
                if ( fileAltExists ){
                } else {
                    sh.writeJSONFile(self.settings.file,
                        sh.readJSONFile(origFile))
                }
                /* if ( sh.fileExists( self.settings.file )) {

                 sh.writeJSONFile(self.settings.file,
                 sh.readJSONFile(origFile))
                 }*/
            }

            if ( fileExists ){

                //self.records = sh.readJSONFile(self.settings.file);
                //doDefault = true
            }


            if ( fileExists ){
                self.records = sh.readJSONFile(self.settings.file);
                //doDefault = true
            }
            if ( self.settings.reset != false ) {
                if (self.settings.gen != null) {
                    var genSettings = self.settings;
                    sh.mergeObjects(self.settings.gen, genSettings); //put later items on top
                    genSettings.requiredFields = self.settings.requiredFields;
                    if (sh.fileExists(self.settings.file) == false || self.settings.reset == true) {
                        var gen = new GenerateData();
                        self.records = gen.create(genSettings);
                    } else {
                        try {
                            self.records = JSON.parse(sh.readFile(self.settings.file))
                        } catch (E) {
                            console.error('cant read package');
                            self.records = [];
                        }
                    }
                } else {
                    if (self.settings.fxReset != null) {
                        self.records = self.settings.fxReset();
                        doDefault = true
                    }
                }
            }



            self.verifyTimeStamps()
            self.updateRecords();

        } else {

        }


        self.nextId = 0;
        if ( self.settings.doDefault || doDefault) {
            self.dict = {}
            for (var i = 0; i < self.records.length; i++) {
                var r = self.records[i];
                if (r.id == null) {
                    self.nextId++;
                    r.id = self.nextId;
                }
                self.dict[r.id] = r;
            }
            self.nextId = self.records.length; //-1;
        }


        var highest = 0;
        sh.each(self.records, function getHighestId(i, obj){
            if ( obj.id > highest ) {
                highest = obj.id
            }
        })
        self.nextId = highest;

        if ( fxResetCallback != null ) {  fxResetCallback();  }

    }

    p.showId = function showId(id, name) {
        console.log(name,
            sh.toJSONString(self.getId(id)) );
    }

    function defineUtils() {
        p.utils = {}

        /**
         * Updates the timestamp on the objecy
         */
        p.utils.updateTimestamps = function updateTimestamps(item, assumeUpdate) {
           //asdf.g
            if ( self.settings.timestamps == false ) {
                return;
            }
            if ( item.createdAt == null && assumeUpdate != true ) {
                item.createdAt = new Date();
                item.updatedAt = new Date();
            } else {
                item.updatedAt = new Date();
            }
        }


        p.verifyTimeStamps = function verifyTimeStamps(obj, updatedOnly) {
            if ( self.settings.addTimestamps == false  )
                return;

            if ( obj != null ) {
                if ( v.createdAt == null ) v.createdAt = new Date();
                v.updatedAt = new Date();
                return;
            }

            //why: timestamps are like db records, help with sorting
            sh.each(self.records, function checkForField(k,v){
                if ( v.createdAt == null ) {
                    v.createdAt = new Date();
                }

                if ( v.updatedAt == null ) {
                    v.updatedAt = new Date();
                }
            }) 
        }



        

        /**
         * Updates object from to
         */
        p.utils.updateItem = function updateItem(from, to, cb, silentNoDbg) {
            //asdf.g
            if ( self.settings.actor != null ){
                self.settings.actor.utils.updateItem(from, to, cb, silentNoDbg);
                /*function fxGotLength(count) {
                 self.lastLength = count
                 sh.callIfDefined(cb, to)
                 }*/
                return;
            }
            sh.each(from, function updateProps(k, v){
                to[k]=v;
            });
            sh.callIfDefined(cb, to)
        }

        p.utils.findOne = function findOne(query) {
            return self.utils.find(query)[0]
        }
        /**
         * Updates object from to
         */
        p.utils.find = function find(query) {
            //if settings.database

            var matches = []
            var skipQueryProps = ['limit'];
            var limit = query.limit;

            //reverse so we can see the opposite
            sh.each(self.records.reverse(), function checkForField(k,item){
                if ( limit != null ) {
                    if ( matches.length >= limit ) {
                        return false;
                    }
                }
                if ( query.query != null ) {
                    if (  sh.includes(item.name, query.query, true ) ) {
                        matches.push(item);
                    }
                    return;
                }

                var failToMatch = false;

                sh.each(query, function matchVAl(k,v){
                    if (sh.includes(skipQueryProps, k) ) { return }
                    if (  sh.includes(item[k], v , true) ) {

                        return;
                    }
                    failToMatch = true
                    return false;
                })

                if ( failToMatch == false ) {
                    matches.push(item);
                }


            })


            return matches;
        }



        p.utils.getLength = function getLength(fxCallback) {
            if ( self.settings.actor != null ){
                self.settings.actor.utils.getLength(fxGotLength);
                function fxGotLength(count) {
                    self.lastLength = count
                    fxCallback(count);
                }
                return;
            }
            self.lastLength = self.records.length
            if ( fxCallback != null ) {
                fxCallback(self.records.length);
            }

            return self.records.length;//.find(query)[0]
        }

        p.utils.empty = function empty(fxCallback) {
            if ( self.settings.actor != null ){
                self.settings.actor.utils.empty(fxCallback);
                return;
            }
            if ( fxCallback != null ) {
                fxCallback(self.records.length);
            }
        }


        /**
         * Add ok method to express response object
         * @param res
         */
        p.utils.genRestOkStub  = function (req, res) {
            res.ok = function ok(x){
                if ( req.ok != null ) {
                    req.ok(x);
                    return;
                }
                res.send(x)
            }
        }

        p.proc = function proc() {
            sh.sLog(arguments)
        }
    }
    defineUtils()


    function defineTestUtils(t) {
        self.testUtils = {};


        var urls = {}
        function makeName(end) {
            var url = '/api/'+self.settings.name
            if ( end != null && end != ''){
                url +='/'+end
            }
            //if you need port set pass to EasyRemoteTester
            /* if ( self.settings.port != null ) {
             url = ':'+self.settings.port+url;
             }*/
            return url
        }
        urls.create = t.utils.createTestingUrl(makeName(''))
        urls.get = t.utils.createTestingUrl(makeName())
        urls.update = t.utils.createTestingUrl(makeName('update'))
        urls.delete = t.utils.createTestingUrl(makeName('delete'))
        urls.list = t.utils.createTestingUrl(makeName('list'))
        urls.search = t.utils.createTestingUrl(makeName('search'))
        urls.count = t.utils.createTestingUrl(makeName('count'))


        urls.get = {}
        urls.get.create = t.utils.createTestingUrl(makeName('create'))
        self.testUtils.urls = urls;

        self.testUtils.create = function create(t, item, url ) {
            url = sh.dv(url, urls.create);
            t.add(function testLogin() {
                t.quickRequest(url+'/',
                    'post', result, item, false);
                function result(body) {
                    //do a check size ...
                    t.cb();
                    //t.cb(t.key);
                }
            });
        }
        self.testUtils.create_get = function create(t, item, url ) {
            url = sh.dv(url, urls.get.create);
            t.add(function testLogin() {
                t.quickRequest(url+'/',
                    'get', result, item);
                function result(body) {
                    //do a check size ...
                    t.lastRequestOK()
                    t.cb();
                    //t.cb(t.key);
                }
            });
        }

        self.testUtils.search = function search(t, query, url ) {
            url = sh.dv(url, urls.search);
            t.add(function testLogin() {
                t.quickRequest(url,
                    'get', result, query);

                function result(body) {
                    t.lastRequestOK()
                    t.cb(body);
                    return;
                }
            });
            return;
        }


    }
    self.defineTestUtils = defineTestUtils
}

exports.RestHelper = IdModelHelper;
exports.RestHelper.types = {}
exports.RestHelper.types.GenDataIfEmpty = 'GenDataIfEmpty'
//exports.RestHelper.types = {}

if ( module.parent == null ) {

    var express = require('express'),
        expressRest = require('express-rest');

    var app = express();
    //var cors = require('cors')
    //CORS middleware
    var allowCrossDomain = function(req, res, next) {
        res.header('Access-Control-Allow-Origin', 'example.com');
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type');

        next();
    }
    /*
     var records = [
     {value: 'Apple'},
     {value: 'Banana'}
     ];

     rest.get('/api/food', function(req, rest) {
     rest.ok(records);
     });

     rest.get('/api/food/:id', function(req, rest) {
     var record = records[req.params.id];
     if (record) rest.ok(record);
     else rest.notFound();
     });

     rest.put('/api/food/:id', function(req, rest) {
     records[req.params.id] = req.body;
     return rest.accepted('/api/food/' + encodeURI(req.params.id));
     });

     rest.post('/api/food', function(req, rest) {
     records.push(req.body);
     rest.created('/api/food/' + (records.length - 1));
     });

     rest.delete('/api/food/:id', function(req, rest) {
     delete records[req.params.id];
     rest.gone();
     })*/


    var tasks = new IdModelHelper();
    var taskApiSettings = {}
    var initTasks = [] ;
    initTasks.push({id:0, name:'Complete Car'})
    initTasks.push({id:1, name:'Complete House'})
    taskApiSettings.model = initTasks
    taskApiSettings.name = 'tasks'
    taskApiSettings.file = 'rest_helper/tasks.json'
    var tS = taskApiSettings;
    tS.createGetPostRoutes = true;
    tS.requiredFields = {name:""}
    tS.reset = false;
    tS.reset = true;
    tS.server = app
    tasks.load(taskApiSettings)


    app.use(function(req, res, next) {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
        next();
    })
    //app.use(cors())
    app.use(allowCrossDomain);
    app.listen(5001);


    var TestHelper = shelpers.TestHelper;
    var reqPost = TestHelper.reqPost;


    var self = {}
    self.settings = {}
    self.settings.port = 5001;

    var types = {};
    types.POST = 'POST'
    types.GET = 'GET'
    types.PUT = 'PUT'

    types.errors = {}
    types.errors.recordDoesNotExist = 'Error: record does not exist'

    function testRestHelper() {

        self.quickRequest = function quickRequest(url, method, fx, postData, doRegPost) {
            if ( method == null ) {
                method = types.GET
            }
            var reqoptions = {}
            reqoptions.url = 'http://localhost:'+self.settings.port+'/'+url
            if ( postData == null ) { postData = {} }
            if ( method == types.POST || method == types.PUT ) {
                if ( doRegPost ) {
                    reqoptions.form = postData
                } else {
                    //reqoptions.json = true
                    //reqoptions.body = "gg"
                    reqoptions.json = true
                    reqoptions.body = postData
                }
            } else {
                reqoptions.qs = postData
            }

            reqoptions.method = method
            reqoptions.showBody =  true;
            reqoptions.fx2 = function storeContents(body, resp){
                console.log(reqoptions.url, 'test ok...')
                try {
                    body = JSON.parse(body)
                } catch ( e ) {

                }
                if ( fx ) {
                    fx(body, resp)
                }
            };
            reqoptions.name = 'test ' + sh.paren(url)
            console.log('testing...')
            reqPost(reqoptions)
        }


        var verbs = {}
        verbs.actions = {}
        verbs.isJSON='isJSON'
        verbs.hasXResults = function hasXResults(amt) {


        }
        //has(6).results()
        //create task
        //list tasks
        //show all tasks
        //create task via put
        //create task


        /*

         new Verb().has(6).isJSON
         json.length == 6

         */




        var token = {}
        var work = new PromiseHelperV3();
        token.silentToken = true
        work.wait = token.simulate==false;
        work.startChain(token)
        /* *//*           .add(self.searchByName)
         .log()
         .add(self.getFirstQuery)
         .add(self.convertMagnetLinkToTorrent)
         .log()
         .add(self.returnMagnetLink)*//*
         .add(self.testGet)
         .add(self.get_create)
         .end();*/





        var data = {}
        data.expectedRecordLength = tasks.records.length;
        data.checkRecordSize = function checkRecordSize() {
            return  tasks.records.length == data.expectedRecordLength
        }
        data.addItem = function addItem() {
            data.expectedRecordLength++;
        }
        data.removeItem = function removeItem() {
            data.expectedRecordLength--;
        }

        data.bodyHasError = function bodyHasError(bodyResponse) {
            if ( sh.startsWith(bodyResponse, 'Cannot')){
                return true;
            }
            return sh.includes(bodyResponse, 'Error')
        }

        data.isFailure = function isFailure(resp) {
            return resp.statusCode == 404
        }



        function assert(eq, msg) {
            if ( eq == false ){
                throw new Error(msg);
            }
        }


        function testFauxGetRoutes() {


            self.testGet = function testGet(token, cb) {
                self.quickRequest('api/tasks', 'get', result, {user_id: "6"})
                function result() {
                    tasks.showId(0, 'lll');
                    assert(tasks.records.length == 2, 'did not reset')
                    cb();
                }
            }
            work.add(self.testGet);


            self.get_create = function get_create(token, cb) {
                self.quickRequest('api/tasks/create', 'get', result, {name: "randomTask"})
                data.addItem();
                function result() {
                    assert(data.checkRecordSize(), 'did not add task properly')
                    cb();
                }
            }
            work.add(self.get_create);


            self.get_update = function get_update(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/update', 'get', result, {id: 0, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not add task properly')
                    cb();
                }
            }
            work.add(self.get_update);


            self.get_update = function get_update(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/update', 'get', result, {id: 0, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not add task properly')
                    cb();
                }
            }
            work.add(self.get_update);

            self.get_update_wrong = function get_update_wrong(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/update', 'get', result, {id: -1, name: newName})
                function result(body) {
                    assert(sh.includes(body, types.errors.recordDoesNotExist),
                        'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.get_delete = function get_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                self.quickRequest('api/tasks/delete', 'get', result, {id: 0, name: newName})
                function result(body) {
                    assert(data.checkRecordSize(),
                        'did not delete task properly')
                    cb();
                }
            }
            work.add(self.get_delete);

            self.get_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/delete/' + 6, 'get', result, {id: -1, name: newName})
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    assert(data.checkRecordSize(),
                        'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.get_delete_with_id_broken);


            self.get_delete_with_id = function get_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/tasks/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    assert(data.checkRecordSize(),
                        'did not delete task properly2')
                    cb();
                }
            }
            work.add(self.get_delete_with_id);

        }
        //testFauxGetRoutes();



        function testRestRoutes() {


            self.reset = function reset(token, cb) {
                tasks.resetDp();
                data.expectedRecordLength = 2;
                assert(data.checkRecordSize(), 'did not reset')
                cb();

            }
            work.add(self.reset);


            self.testRestGet = function testRestGet(token, cb) {
                var itemId = 0;
                self.quickRequest('api/tasks/'+itemId, 'get', result )
                function result(body) {
                    assert(body.id == itemId, 'did not get item')
                    cb();
                }
            }
            work.add(self.testRestGet);


            self.rest_create = function rest_create(token, cb) {
                // adsf.g.d
                self.quickRequest('api/tasks', 'POST', result, {name:" rand task"})
                data.addItem();
                function result(body) {
                    assert(data.checkRecordSize(), 'did not add task properly')
                    cb();
                }
            }
            work.add(self.rest_create);


            self.rest_update = function rest_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 0
                self.quickRequest('api/tasks/'+idToUpdate, 'PUT', result, {id: idToUpdate, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not restfully update task properly')
                    cb();
                }
            }
            work.add(self.rest_update);


            self.rest_update_wrong = function rest_update_wrong(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/'+9999, 'get', result, {id: 0, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not add task properly')
                    cb();
                }
            }
            //work.add(self.rest_update_wrong);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/'+"-1", 'get', result, {id: -1, name: newName})
                function result(body, resp) {
                    assert(data.isFailure(resp), 'Updaded invalid id')
                    // assert(sh.includes(body, types.errors.recordDoesNotExist),
                    //     'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.rest_delete = function rest_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                var deleteId = 0;
                self.quickRequest('api/tasks/'+deleteId, 'DELETE', result )
                function result(body) {
                    assert(data.checkRecordSize(),
                        'did not delete task properly')
                    cb();
                }
            }
            work.add(self.rest_delete);

            self.rest_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/tasks/delete/' + 6, 'DELETE', result )
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    //assert(data.checkrecordsize(),
                    //    'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.rest_delete_with_id_broken);


            self.rest_delete_with_id = function rest_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/tasks/delete/' + 1, 'get', result, {id: -1})
                function result(body) {
                    assert(data.checkRecordSize(),
                        'did not delete task properly2')
                    cb();
                }
            }
            work.add(self.rest_delete_with_id);

        }
        testRestRoutes();
        /*

         self.quickRequest('api/tasks/update', 'get', null, {id:0, name:"randomTask_@"})
         self.quickRequest('api/tasks/update', 'get', null, {id:-1, name:"randomTask_@"})

         self.quickRequest('api/tasks/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/tasks/delete', 'get', null, {id:-1, name:"randomTask_@"})


         //l crud//
         self.quickRequest('api/tasks', 'get', null, {user_id:"6"})
         self.quickRequest('api/tasks', 'put', null, {name:"randomTask"})
         self.quickRequest('api/tasks/1', 'get', null )
         self.quickRequest('api/tasks/1', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/tasks/1', 'delete', null )

         self.quickRequest('api/tasks/search', 'get', null, {id:-1, name:"randomTask", __limit:1})
         self.quickRequest('api/tasks/search', 'get', null, {id:1, name:"randomTask", __limit:1, __exact:true})


         self.quickRequest('api/tasks/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/tasks/delete', 'get', null, {id:-1, name:"randomTask_@"})
         */



        function testSearchRoute() {


            self.reset = function reset(token, cb) {
                taskApiSettings.model = []
                GenerateData = shelpers.GenerateData;
                var gen = new GenerateData();
                taskApiSettings.model = gen.create(100, function (item, id, dp){
                    item.name = id;
                    item.id = id;

                    item.desc = GenerateData.getName();
                })
                tasks.resetDp();
                data.expectedRecordLength = 100;
                assert(data.checkRecordSize(), 'did not reset')
                cb();

            }
            work.add(self.reset);


            self.testQuerySearch = function testQuerySearch(token, cb) {
                self.quickRequest('api/tasks/search', 'get', result, {query:1} )
                function result(body) {
                    assert(body.length > 10, 'did not get enough results')
                    cb();
                }
            }
            work.add(self.testQuerySearch);


            self.testQuerySearch_limit = function testQuerySearch(token, cb) {
                self.quickRequest('api/tasks/search', 'get', result, {query:1, limit:10} )
                function result(body) {
                    assert(body.length == 10, 'did not get enough results')
                    cb();
                }
            }
            work.add(self.testQuerySearch_limit);



            self.testQuerySearch_limit_1 = function testQuerySearch(token, cb) {
                self.quickRequest('api/tasks/search', 'get', result, {query:11, limit:10} )
                function result(body) {
                    assert(body.length == 1, 'did not get enough results')
                    cb();
                }
            }
            work.add(self.testQuerySearch_limit_1);


            self.testQuerySearch_limit_piecemeal = function testQuerySearch(token, cb) {
                tasks.getId(11).desc = 'Find Desc'
                self.quickRequest('api/tasks/search', 'get', result, {name:"11", desc:tasks.getId(11).desc} )
                function result(body) {
                    assert(body.length == 1, 'did not get enough results')
                    cb();
                }
            }
            work.add(self.testQuerySearch_limit_piecemeal);

            self.testQuerySearch_limit_piecemealb = function testQuerySearch(token, cb) {
                tasks.getId(11).desc = 'Find Desc';
                self.quickRequest('api/tasks/search', 'get', result,
                    {name:"11", desc:tasks.getId(11).desc.slice(0,6)} )
                function result(body) {
                    assert(body.length == 1, 'search doesn\'t work on wild cards');
                    cb();
                }
            }
            work.add(self.testQuerySearch_limit_piecemealb);

            self.testQuerySearch_limit_piecemealb_findNone = function testQuerySearch(token, cb) {
                tasks.getId(11).desc = 'Find Desc';
                self.quickRequest('api/tasks/search', 'get', result,
                    {name:"11", desc:'llll'} )
                function result(body) {
                    assert(body.length == 0, 'search return more than 0 results for bad query');
                    cb();
                }
            }
            work.add(self.testQuerySearch_limit_piecemealb_findNone);
        }
        testSearchRoute();

        //crud

        setTimeout(function () {
            tasks.showId(0, 'lll');
        }, 500)

    }

    testRestHelper();

}

