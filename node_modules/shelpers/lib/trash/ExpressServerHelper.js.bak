/**
 * Created by user1 on 4/27/14.
 * Makes servers 'rebootable' hot-swappable
 * will send request to kill another server
 */
var shelpers = require('shelpers')
var sh = require('shelpers').shelpers
var properties = require('properties')
var fs = require('fs')
var request = require('request')
var express = require('express')

var TestHelper = shelpers.TestHelper;
var reqPost = TestHelper.reqPost;

function ExpressServerHelper() {
    var p = ExpressServerHelper.prototype
    var self = this;

    self.settings = {}

    p.setup = function setup(app, exitProcess, fxExit, id, _self) {
        self.app = app
        self.server = app;
        app.get('/exit', function exitFromServerProcess(req, res) {
            self.proc('header exit request', id, _self)
            res.end();
            if (exitProcess != false && exitProcess != "false") {
                setTimeout(function endLater() {
                    process.exit()
                }, 500)
            }
            if (fxExit != null) {
                fxExit()
            }
            if (self.server != null) {
                try {
                    self.server.close(function() {
                        console.log("Closed out remaining connections.");
                        //  process.exit()
                    });
                }catch ( e )
                {
                    console.error(e)
                }
            }

        })

        return
        process.on('uncaughtException', self.uncaughtExceptionHandler)
        //remove lisnter ...
        setTimeout(function removeUncaught() {
            process.removeListener('uncaughtException', self.uncaughtExceptionHandler)
        }, 2000)
    }


    p.uncaughtExceptionHandler = function uncaughtExceptionHandler(err) {
        if(err.errno === 'EADDRINUSE') {
            console.log('...');
            console.log("\n", 'you already have the server running, shut down that instance', self.id)
            //jump port
        }
        else {

            console.error(err);
            console.error(  err.stack);
            console.error(  err.message);
            //throw err
            setTimeout(function showError() {
                //process.exit(1);
                throw err
            }, 500)
            //showError()

        }
    }

    /**
     * Will destroy the old server if found
     * @param fxCallback
     */
    p.exitExisting = function exitExisting(fxCallback, serverPortNumber) {
        var options = {}
        options.url = 'http://localhost:'+serverPortNumber+'/exit'
        self.proc('serverPortNumber', serverPortNumber);
        if ( sh.isNull(serverPortNumber)){
            throw new Error('need a valid port number')
        }
        options.timeout = 1500 //wait before assume previous instance does not exist
        request(options, function onExitResponse (error, response, body) {
            self.proc('...',serverPortNumber, error, body) //you will get errof if alreadyended
            sh.waitXSecs(1, function attemptToStartServer() {
                sh.callIfDefined(fxCallback)
            }, 'attemptToStartServer')

        })
    }

    p.startup = function startup(fxCallback, serverPortNumber) {
        p.exitExisting(fxCallback, serverPortNumber)
        self.settings.port = serverPortNumber;
    }


    /**
     * This code should be better organized
     * Request Helpers
     * Test Helpers
     */
    function createTestHelper(){

        p.testHelper = {}

        p.asdf = function asdf () {

        }


        p.testHelper.quickRequest = function quickRequest(url, method, fx) {
            if ( method == null ) {
                method = 'GET'
            }
            var reqoptions = {}
            reqoptions.url = 'http://localhost:'+self.settings.port+'/'+url
            reqoptions.form = {}
            reqoptions.method = method
            reqoptions.showBody =  true;
            reqoptions.fx2 = function storeContents(body){
                console.log(reqoptions.url, 'test ok...')
            };
            reqoptions.name = 'test ' + sh.paren(url)
            //console.log('testing...')
            reqPost(reqoptions)
        }

        /**
         * Will throw error if request does not return status ok
         * @param url
         * @param method
         * @param fx
         */
        p.testHelper.verifyResponse = function verifyResponse(url, method, fx) {
            if ( method == null ) {
                method = 'GET'
            }
            var reqoptions = {}
            reqoptions.url = 'http://localhost:'+self.settings.port+'/'+url
            reqoptions.form = {}
            reqoptions.method = method
            reqoptions.showBody =  false;
            reqoptions.silent = true;
            reqoptions.throwErrorIfStatusCodeNotEqual = 200;
            //sh.getClassName()
            reqoptions.fx2 = function storeContents(body){
                console.log(reqoptions.url, 'test ok...', body.length)
            };
            reqoptions.name = 'test ' + sh.paren(url)
            //console.log('testing...')
            reqPost(reqoptions)
        }



    }
    createTestHelper();


    /**
     * Helper provides routes to jquery, handlebars, bootstrap, underscore
     * for easy mocking
     */
    function createJqueryRoutesHelper() {
        self.createJqueryRoutes = function createJqueryRoutes() {
            self.server.get('/jquery', function getJquery(req, res) {
                var fileName = 'jquery-2.0.2.js.ignore_scan'
                var contents = sh.readFile(__dirname+'/'+'public_html/' + fileName )
                res.end(contents);
            })

            function addRoute_MethodToFile(name, fileName) {
                if ( sh.startsWith(name, '/')==false ) {
                    name = '/'+name
                }
                self.server.get(name, function getFile_ByFileName(req, res) {
                    var contents = sh.readFile(__dirname+'/'+'public_html/' + fileName )
                    res.end(contents);
                })
            }
            addRoute_MethodToFile('jquery.js', 'jquery-2.0.2.js.ignore_scan')
            addRoute_MethodToFile('bootstrap.js', 'bootstrap.min.3.js.ignore_scan')
            addRoute_MethodToFile('bootstrap.css', 'bootstrap.min.css.ignore_scan')
            addRoute_MethodToFile('bootstrap-theme.css', 'bootstrap-theme.min.css.ignore_scan')
            //addRoute_MethodToFile('bootstrap.js', '')
            addRoute_MethodToFile('handlebars.js', 'handlebars-v1.3.0.js.ignore_scan')
            addRoute_MethodToFile('underscore.js', 'underscore.js.ignore_scan')
            //addRoute_MethodToFile('handlebars.js', '')

        }


        /**
         * Request all jquery resources using built in
         * request test helper
         */
        self.testJqueryRoutes = function testJqueryRoutes() {
            var eSH = self;
            eSH.testHelper.verifyResponse('jquery.js')
            eSH.testHelper.verifyResponse('bootstrap.js')
            eSH.testHelper.verifyResponse('bootstrap.css')
            eSH.testHelper.verifyResponse('bootstrap-theme.css')
            eSH.testHelper.verifyResponse('handlebars.js')
            eSH.testHelper.verifyResponse('underscore.js')
        }
    }
    createJqueryRoutesHelper();



    /**
     * Helper provides routes to jquery, handlebars, bootstrap, underscore
     * for easy mocking
     */
    function createHelperRoutesHelper() {
        self.createHelperRoutes = function createHelperRoutes() {
            function addRoute_MethodToFile(name, fileName) {
                if ( sh.startsWith(name, '/')==false ) {
                    name = '/'+name
                }
                self.server.get(name, function getFile_ByFileName(req, res) {
                    var contents = sh.readFile(__dirname+'/'+'public_html_helpers/' + fileName )
                    res.end(contents);
                })
            }
            addRoute_MethodToFile('quickform.js', 'quickform.js.ignore_scan')
            addRoute_MethodToFile('quicklist.js', 'quicklist.js.ignore_scan')
        }

        /**
         * Request all helper resources using built in
         * request test helper
         */
        self.testHelperRoutes = function testHelperRoutes() {
            var eSH = self;
            eSH.testHelper.verifyResponse('quickform.js')
            eSH.testHelper.verifyResponse('quicklist.js')
        }
    }
    createHelperRoutesHelper();
    /**
     * alias for express.static method
     * @param dir
     */
    p.addResourceDir = function addResourceDir(dir) {
        //server.use(express.static(__dirname + '/public'));
        self.server.use(express.static(dir));

    }

    p.proc = function proc(options ){
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }
}


/**
 * Convience static method for creating an instance
 * @param config
 */
ExpressServerHelper.new = function  createNewServerHelper(config) {
    var port = config.port;

    var server = null;
    if ( config.server == null ) {
        server = express();
    } else {
        server = config.server;
    }

    /*

     var cors = require('express-cors');
     server.use(cors({allowedOrigins:[
     '127.0.0.1',
     '192.168.81.133' ,
     '192.168.81.133:10001']}))
     */

    server.use(function(req, res, next) {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
        next();
    });

    sh.callIfDefined( config.fxServerInit);

    server.use(function(req, res, next) {
        console.error('ESH', req.originalUrl)
        if ( eSH.globalMiddleware != null ) {
            if (eSH.globalMiddleware(req, res, next)) {
                return;
            }
        }
        next();
    });


    if ( config.bodyParser != false  ) {
        //eSH.server.use(express.bodyParser());
        //server.use(require('connect').bodyParser())
        server.use(express.bodyParser())
    }


    var eSH = new ExpressServerHelper()
    if ( config.server == null ) {
        eSH.settings = config;
        eSH.setup(server);
        var fxInit = null;


        eSH.startup(function onPreviousInstanceRemoved() {
            server.listen(config.port);
            if (config.fx != null) {
                config.fx();
            }
            if (fxInit != null) {
                fxInit()
            }
        }, config.port)
    } else {
        eSH.server = server;
        eSH.app = server;
    }

    server.eSH = eSH;


    if ( config.addJquery == true ) {
        eSH.createJqueryRoutes();
    }

    if ( config.testJquery ) {
        fxInit = eSH.testJqueryRoutes
    }

    if  ( config.addWildCards ) {
        /**
         * For quick prototyping support this route
         * @type {ExpressServerHelper}
         */
        //TODO move above
        var self = eSH;
        var p = self;

        p.processWildCardUrls =   function processWildCardUrls(req, res, next) {
            if (req.originalUrl == '/favicon.ico') {
                res.end()
                return;
            }

            var split = req.originalUrl.split('/');
            var reqMethod = split[0];
            var methodRequest = null

            if ( sh.includes(['get', 'post'], req.method.toLowerCase()  ) ) {
                methodRequest = req.method.toLowerCase()
            }

            if ( sh.includes(['get', 'post'], reqMethod  ) ) {
                self.proc('reqMethod', reqMethod)
                methodRequest = reqMethod
            }

            if ( methodRequest != null ) {
                //find in directory
                var dir = 'requests'
                if ( config.addWildCards_Dir != null ) {
                    dir = config.addWildCards_Dir
                    //throw error if dir doesn't exist
                }

                //step: attempt to find file to fulfill request
                var content=null;

                //if get request, test resource name
                var fileName = dir+'/'+split.slice(1).join('-')

                if ( sh.fileExists(fileName) ) {
                    content = sh.readFile(fileName)
                }

                fileName = dir+'/'+methodRequest+'-'+split.slice(1).join('-')

                if ( sh.fileExists(fileName) ) {
                    content = sh.readFile(fileName)
                }
                fileName += '.txt'
                if ( sh.fileExists(fileName) ) {
                    content = sh.readFile(fileName)
                }

                if ( content != null ) {
                    res.end(content)
                    return;
                }
                //function searchFiles(dir, method)
            }

            next();
            return;

            //no match found, return error and 404
            //res.status(404)
            //res.end(req.originalUrl);

        }

        //server.all('/*', self.processWildCardUrls)


    }

    return server;
}


exports.ExpressServerHelper = ExpressServerHelper
exports.ExpressServerHelper.express = express;

if (module.parent == null) {

}
